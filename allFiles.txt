
```
// fonts/emo.json
{
    "metadata": {
        "face": "Emo",
        "style": "Regular",
        "size": 24
    },
    "glyphs": {
        "E": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 24 0 L 24 4 L 4 4 L 4 10 L 20 10 L 20 14 L 4 14 L 4 20 L 24 20 L 24 24 L 0 24 Z"
        },
        "M": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 4 0 L 12 16 L 20 0 L 24 0 L 24 24 L 20 24 L 20 4 L 12 20 L 4 4 L 4 24 L 0 24 Z"
        },
        "O": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 12 0 C 18.627 0 24 5.373 24 12 C 24 18.627 18.627 24 12 24 C 5.373 24 0 18.627 0 12 C 0 5.373 5.373 0 12 0 Z M 12 4 C 7.582 4 4 7.582 4 12 C 4 16.418 7.582 20 12 20 C 16.418 20 20 16.418 20 12 C 20 7.582 16.418 4 12 4 Z"
        },
        "W": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 4 0 L 8 16 L 12 0 L 16 16 L 20 0 L 24 0 L 24 24 L 20 24 L 20 4 L 16 20 L 12 4 L 8 20 L 4 4 L 4 24 L 0 24 Z"
        },
        "R": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 16 0 C 20.418 0 24 3.582 24 8 C 24 12.418 20.418 16 16 16 L 4 16 L 4 24 L 0 24 Z M 4 4 L 4 12 L 16 12 C 18.209 12 20 10.209 20 8 C 20 5.791 18.209 4 16 4 Z"
        },
        "L": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 4 0 L 4 20 L 20 20 L 20 24 L 0 24 Z"
        },
        "D": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 16 0 C 20.418 0 24 3.582 24 8 C 24 12.418 20.418 16 16 16 L 0 16 Z M 4 4 L 4 12 L 16 12 C 18.209 12 20 10.209 20 8 C 20 5.791 18.209 4 16 4 Z"
        }
    }
} 
```

```
// fonts/menu.json
{
    "metadata": {
        "face": "Menu",
        "style": "Regular",
        "size": 24
    },
    "glyphs": {
        "S": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 20 4 C 20 1.791 18.209 0 16 0 L 8 0 C 5.791 0 4 1.791 4 4 L 4 8 L 8 8 L 8 4 L 16 4 L 16 20 L 8 20 L 8 16 L 4 16 L 4 20 C 4 22.209 5.791 24 8 24 L 16 24 C 18.209 24 20 22.209 20 20 Z"
        },
        "T": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 24 0 L 24 4 L 14 4 L 14 24 L 10 24 L 10 4 L 0 4 Z"
        },
        "A": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 12 0 L 24 24 L 20 24 L 18 20 L 6 20 L 4 24 L 0 24 Z M 8 16 L 16 16 L 12 4 Z"
        },
        "R": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 16 0 C 20.418 0 24 3.582 24 8 C 24 12.418 20.418 16 16 16 L 4 16 L 4 24 L 0 24 Z M 4 4 L 4 12 L 16 12 C 18.209 12 20 10.209 20 8 C 20 5.791 18.209 4 16 4 Z"
        },
        "G": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 12 0 C 18.627 0 24 5.373 24 12 C 24 18.627 18.627 24 12 24 C 5.373 24 0 18.627 0 12 C 0 5.373 5.373 0 12 0 Z M 12 4 C 7.582 4 4 7.582 4 12 C 4 16.418 7.582 20 12 20 C 16.418 20 20 16.418 20 12 C 20 7.582 16.418 4 12 4 Z M 12 8 L 16 8 L 16 12 L 12 12 L 12 16 L 16 16 L 16 20 L 8 20 L 8 8 Z"
        },
        "E": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 24 0 L 24 4 L 4 4 L 4 10 L 20 10 L 20 14 L 4 14 L 4 20 L 24 20 L 24 24 L 0 24 Z"
        },
        "L": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 4 0 L 4 20 L 20 20 L 20 24 L 0 24 Z"
        },
        "O": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 12 0 C 18.627 0 24 5.373 24 12 C 24 18.627 18.627 24 12 24 C 5.373 24 0 18.627 0 12 C 0 5.373 5.373 0 12 0 Z M 12 4 C 7.582 4 4 7.582 4 12 C 4 16.418 7.582 20 12 20 C 16.418 20 20 16.418 20 12 C 20 7.582 16.418 4 12 4 Z"
        },
        "D": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 16 0 C 20.418 0 24 3.582 24 8 C 24 12.418 20.418 16 16 16 L 0 16 Z M 4 4 L 4 12 L 16 12 C 18.209 12 20 10.209 20 8 C 20 5.791 18.209 4 16 4 Z"
        },
        "I": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 24 0 L 24 4 L 14 4 L 14 20 L 24 20 L 24 24 L 0 24 L 0 20 L 10 20 L 10 4 L 0 4 Z"
        },
        "N": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 4 0 L 4 16 L 20 0 L 24 0 L 24 24 L 20 24 L 20 8 L 4 24 L 0 24 Z"
        },
        "M": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 4 0 L 12 16 L 20 0 L 24 0 L 24 24 L 20 24 L 20 4 L 12 20 L 4 4 L 4 24 L 0 24 Z"
        },
        "X": {
            "ha": 24,
            "x_min": 0,
            "x_max": 24,
            "y_min": 0,
            "y_max": 24,
            "o": "M 0 0 L 4 0 L 12 10 L 20 0 L 24 0 L 14 12 L 24 24 L 20 24 L 12 14 L 4 24 L 0 24 L 10 12 Z"
        }
    }
} 

```

```
// js/billboard.js
import * as THREE from 'three';
import { createBoxGeometry, createStandardMaterial } from './utils.js';

export class Billboard {
    constructor(scene) {
        // Create billboard frame
        const frameGeometry = createBoxGeometry(8, 4, 0.5);
        const frameMaterial = createStandardMaterial(0x333333, 0.9);
        this.frame = new THREE.Mesh(frameGeometry, frameMaterial);
        
        // Create billboard screen - make it more transparent
        const screenGeometry = createBoxGeometry(7.8, 3.8, 0.1);
        const screenMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        this.screen = new THREE.Mesh(screenGeometry, screenMaterial);
        this.screen.position.z = 0.2; // Slightly in front of frame
        
        // Create billboard group
        this.billboardGroup = new THREE.Group();
        this.billboardGroup.add(this.frame);
        this.billboardGroup.add(this.screen);
        this.billboardGroup.userData.isCollidable = true;
        
        // Position and rotate the billboard
        this.billboardGroup.position.set(0, 3, 8); // 8 units forward from the edge
        
        // Add billboard to scene
        scene.add(this.billboardGroup);
        
        // Add dedicated lighting for the billboard
        this.addBillboardLights(scene);
        
        // Add neon glow effect
        this.addNeonGlow();
        
        // Load and apply the logo texture
        this.loadLogoTexture();

        // Initialize color transition properties
        this.colorIndex = 0;
        this.transitionProgress = 0;
        this.cyberpunkColors = [
            0x00ffff, // Cyan
            0xff00ff, // Magenta
            0x00ff00, // Neon Green
            0xff0000, // Neon Red
            0x0000ff, // Neon Blue
            0xffff00, // Neon Yellow
            0xff00ff, // Magenta (loop back)
        ];
    }
    
    addBillboardLights(scene) {
        // Front spotlight - increased intensity
        const frontSpot = new THREE.SpotLight(0xffffff, 3);
        frontSpot.position.set(0, 5, 12);
        frontSpot.angle = Math.PI / 4;
        frontSpot.penumbra = 0.5;
        frontSpot.decay = 1;
        frontSpot.distance = 20;
        frontSpot.target = this.billboardGroup;
        scene.add(frontSpot);
        
        // Top spotlight - increased intensity
        const topSpot = new THREE.SpotLight(0xffffff, 2);
        topSpot.position.set(0, 8, 8);
        topSpot.angle = Math.PI / 4;
        topSpot.penumbra = 0.5;
        topSpot.decay = 1;
        topSpot.distance = 20;
        topSpot.target = this.billboardGroup;
        scene.add(topSpot);
        
        // Ambient light - increased intensity
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        ambientLight.position.set(0, 3, 8);
        scene.add(ambientLight);
    }
    
    loadLogoTexture() {
        console.log("Loading logo texture...");
        const textureLoader = new THREE.TextureLoader();
        
        // Try loading from different possible paths
        const possiblePaths = [
            '/logo.png',
            './logo.png',
            'logo.png'
        ];
        
        const tryLoadTexture = (path) => {
            console.log("Attempting to load texture from:", path);
            textureLoader.load(
                path,
                (texture) => {
                    console.log("Logo texture loaded successfully from:", path);
                    // Configure texture settings
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.format = THREE.RGBAFormat;
                    texture.flipY = true;
                    this.createLogoMesh(texture);
                },
                (progress) => {
                    console.log("Loading progress for", path + ":", (progress.loaded / progress.total * 100) + '%');
                },
                (error) => {
                    console.error("Error loading texture from:", path);
                    console.error("Error details:", error);
                    // Try next path if available
                    if (possiblePaths.length > 0) {
                        console.log("Trying next path...");
                        tryLoadTexture(possiblePaths.shift());
                    } else {
                        console.error("Failed to load logo texture from all possible paths");
                        console.log("Creating placeholder logo...");
                        this.createPlaceholderLogo();
                    }
                }
            );
        };
        
        // Start with the first path
        tryLoadTexture(possiblePaths.shift());
    }
    
    createLogoMesh(texture) {
        console.log("Creating logo mesh with texture...");
        
        // Configure texture settings
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.format = THREE.RGBAFormat;
        texture.flipY = true;
        
        // Create a plane for the logo
        const logoGeometry = new THREE.PlaneGeometry(5, 2.5);
        const logoMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide
        });
        
        this.logo = new THREE.Mesh(logoGeometry, logoMaterial);
        this.logo.position.z = 0.25;
        
        // Add logo to billboard group
        this.billboardGroup.add(this.logo);
        console.log("Logo mesh created and added to billboard group");
    }
    
    createPlaceholderLogo() {
        // Create a colored plane as placeholder - reduced size
        const logoGeometry = new THREE.PlaneGeometry(5, 2.5); // Reduced from 7.6, 3.6
        const logoMaterial = new THREE.MeshStandardMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            emissive: 0xff00ff,
            emissiveIntensity: 1.0,
            metalness: 0.8,
            roughness: 0.2
        });
        
        this.logo = new THREE.Mesh(logoGeometry, logoMaterial);
        this.logo.position.z = 0.15;
        
        // Add logo to billboard group
        this.billboardGroup.add(this.logo);
    }
    
    addNeonGlow() {
        // Create neon frame glow
        const glowGeometry = createBoxGeometry(8.2, 4.2, 0.6);
        const glowMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.3, // Increased opacity
            emissive: 0x00ffff,
            emissiveIntensity: 1.0, // Increased intensity
            metalness: 0.8,
            roughness: 0.2
        });
        this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
        this.glow.position.z = -0.1; // Behind the frame
        
        // Add glow to billboard group
        this.billboardGroup.add(this.glow);
    }
    
    update(deltaTime) {
        // Update color transition
        this.transitionProgress += deltaTime * 0.5; // Adjust speed by changing multiplier
        
        if (this.transitionProgress >= 1) {
            this.transitionProgress = 0;
            this.colorIndex = (this.colorIndex + 1) % this.cyberpunkColors.length;
        }
        
        // Calculate interpolated color
        const currentColor = this.cyberpunkColors[this.colorIndex];
        const nextColor = this.cyberpunkColors[(this.colorIndex + 1) % this.cyberpunkColors.length];
        
        const currentRGB = new THREE.Color(currentColor);
        const nextRGB = new THREE.Color(nextColor);
        
        const interpolatedColor = new THREE.Color();
        interpolatedColor.r = currentRGB.r + (nextRGB.r - currentRGB.r) * this.transitionProgress;
        interpolatedColor.g = currentRGB.g + (nextRGB.g - currentRGB.g) * this.transitionProgress;
        interpolatedColor.b = currentRGB.b + (nextRGB.b - currentRGB.b) * this.transitionProgress;
        
        // Update glow color and intensity
        if (this.glow) {
            this.glow.material.color = interpolatedColor;
            this.glow.material.emissive = interpolatedColor;
            this.glow.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.001) * 0.1;
        }
    }
} 
```

```
// js/character.js
import * as THREE from 'three';
import { createStandardMaterial, createBoxGeometry } from './utils.js';
import { Vinyl } from './vinyl.js';
import { SpeechBubble } from './speechBubble.js';
import { Box3 } from 'three'; // Import Box3

export class Character {
    constructor(scene, chatSystem, name = 'Character') {
        this.scene = scene;
        this.chatSystem = chatSystem; // Store chatSystem
        this.name = name; // Store name
        this.createCharacter();
        this.setupState();
        
        // Add vinyl shooting properties
        this.vinyls = [];
        this.lastShootTime = 0;
        this.shootCooldown = 0.5; // Half second cooldown between shots
        
        // Add speech bubble properties
        this.activeSpeechBubble = null;

        // Add to scene
        this.scene.add(this.characterGroup);
        console.log(`${this.name} added to scene:`, scene.uuid);
    }

    createCharacter() {
        // Create character group
        this.characterGroup = new THREE.Group();
        this.characterGroup.name = this.name; // Assign name to group
        
        // Body - slim hoodie with better proportions
        const bodyGeometry = createBoxGeometry(0.5, 1.2, 0.3); // Slimmer body
        const bodyMaterial = createStandardMaterial(0x000000, 0.9); // Pure black for hoodie
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.set(0, 0.6, 0); // Lower body position
        body.name = 'hoodie';
        this.characterGroup.add(body);
        
        // Hood - more defined shape
        const hoodGeometry = createBoxGeometry(0.45, 0.3, 0.3); // Slimmer hood
        const hoodMaterial = createStandardMaterial(0x000000, 0.9);
        const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
        hood.position.set(0, 1.25, -0.05);
        hood.name = 'hood';
        this.characterGroup.add(hood);

        // Hoodie pocket
        const pocketGeometry = createBoxGeometry(0.35, 0.15, 0.05); // Slimmer pocket
        const pocket = new THREE.Mesh(pocketGeometry, bodyMaterial);
        pocket.position.set(0, 0.35, 0.15);
        pocket.name = 'pocket';
        this.characterGroup.add(pocket);

        // Hoodie drawstrings
        const drawstringGeometry = createBoxGeometry(0.03, 0.15, 0.03); // Thinner drawstrings
        const drawstringMaterial = createStandardMaterial(0xFFFFFF, 0.9);
        
        const leftDrawstring = new THREE.Mesh(drawstringGeometry, drawstringMaterial);
        leftDrawstring.position.set(-0.12, 1.1, 0.12);
        leftDrawstring.rotation.z = 0.2;
        this.characterGroup.add(leftDrawstring);
        
        const rightDrawstring = new THREE.Mesh(drawstringGeometry, drawstringMaterial);
        rightDrawstring.position.set(0.12, 1.1, 0.12);
        rightDrawstring.rotation.z = -0.2;
        this.characterGroup.add(rightDrawstring);
        
        // Head - more angular with defined jawline
        const headGeometry = createBoxGeometry(0.32, 0.4, 0.32); // Slightly taller for jawline
        const headMaterial = createStandardMaterial(0xffdbac, 0.9);
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.set(0, 1.4, 0);
        head.name = 'head';
        this.characterGroup.add(head);
        
        // Face - more angular with stronger jawline
        const faceGeometry = createBoxGeometry(0.32, 0.4, 0.08); // Deeper face for more definition
        const faceMaterial = createStandardMaterial(0xffdbac, 0.9);
        const face = new THREE.Mesh(faceGeometry, faceMaterial);
        face.position.set(0, 1.4, 0.16);
        face.name = 'face';
        this.characterGroup.add(face);

        // Jaw definition
        const jawGeometry = createBoxGeometry(0.28, 0.15, 0.08);
        const jaw = new THREE.Mesh(jawGeometry, faceMaterial);
        jaw.position.set(0, 1.25, 0.16);
        jaw.name = 'jaw';
        this.characterGroup.add(jaw);
        
        // Eyes - more determined, slightly angled
        const eyeGeometry = createBoxGeometry(0.08, 0.1, 0.05);
        const eyeMaterial = createStandardMaterial(0x000000, 0.9);
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.09, 1.48, 0.21);
        leftEye.rotation.z = -0.15;
        leftEye.name = 'leftEye';
        this.characterGroup.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.09, 1.48, 0.21);
        rightEye.rotation.z = -0.15;
        rightEye.name = 'rightEye';
        this.characterGroup.add(rightEye);

        // Eyebrows - more angular and expressive
        const eyebrowGeometry = createBoxGeometry(0.12, 0.035, 0.02);
        const eyebrowMaterial = createStandardMaterial(0x2a1003, 0.9); // Darker brown for contrast
        
        const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
        leftEyebrow.position.set(-0.09, 1.56, 0.21);
        leftEyebrow.rotation.z = -0.3; // More angled for determined expression
        this.characterGroup.add(leftEyebrow);
        
        const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
        rightEyebrow.position.set(0.09, 1.56, 0.21);
        rightEyebrow.rotation.z = -0.3; // More angled for determined expression
        this.characterGroup.add(rightEyebrow);

        // Inner eyebrow details for thickness
        const innerEyebrowGeometry = createBoxGeometry(0.08, 0.03, 0.02);
        
        const leftInnerEyebrow = new THREE.Mesh(innerEyebrowGeometry, eyebrowMaterial);
        leftInnerEyebrow.position.set(-0.09, 1.555, 0.22);
        leftInnerEyebrow.rotation.z = -0.3;
        this.characterGroup.add(leftInnerEyebrow);
        
        const rightInnerEyebrow = new THREE.Mesh(innerEyebrowGeometry, eyebrowMaterial);
        rightInnerEyebrow.position.set(0.09, 1.555, 0.22);
        rightInnerEyebrow.rotation.z = -0.3;
        this.characterGroup.add(rightInnerEyebrow);

        // Nose - angular and defined
        const noseBridgeGeometry = createBoxGeometry(0.04, 0.12, 0.06);
        const noseMaterial = createStandardMaterial(0xf0c5a3, 0.9); // Slightly darker than face for definition
        
        const noseBridge = new THREE.Mesh(noseBridgeGeometry, noseMaterial);
        noseBridge.position.set(0, 1.45, 0.23);
        noseBridge.rotation.x = 0.1; // Slight angle for profile
        this.characterGroup.add(noseBridge);

        // Nose tip
        const noseTipGeometry = createBoxGeometry(0.06, 0.06, 0.04);
        const noseTip = new THREE.Mesh(noseTipGeometry, noseMaterial);
        noseTip.position.set(0, 1.41, 0.25);
        this.characterGroup.add(noseTip);

        // Nose bottom shadow
        const noseBottomGeometry = createBoxGeometry(0.08, 0.02, 0.02);
        const noseShadowMaterial = createStandardMaterial(0xe0b593, 0.9); // Darker for shadow
        const noseBottom = new THREE.Mesh(noseBottomGeometry, noseShadowMaterial);
        noseBottom.position.set(0, 1.39, 0.24);
        this.characterGroup.add(noseBottom);
        
        // Hair - refined styling
        const hairMaterial = createStandardMaterial(0x3a1f13, 0.9); // Dark brown

        // Main hair volume
        const hairGeometry = createBoxGeometry(0.34, 0.15, 0.34);
        const hair = new THREE.Mesh(hairGeometry, hairMaterial);
        hair.position.set(0, 1.65, 0);
        hair.name = 'hair';
        this.characterGroup.add(hair);

        // Front hair piece - more dramatic sweep
        const hairFrontGeometry = createBoxGeometry(0.32, 0.15, 0.25);
        const hairFront = new THREE.Mesh(hairFrontGeometry, hairMaterial);
        hairFront.position.set(0, 1.72, 0.12);
        hairFront.rotation.x = -0.4; // More dramatic upward angle
        this.characterGroup.add(hairFront);

        // Additional front sweep
        const hairSweepGeometry = createBoxGeometry(0.28, 0.12, 0.2);
        const hairSweep = new THREE.Mesh(hairSweepGeometry, hairMaterial);
        hairSweep.position.set(0, 1.75, 0.18);
        hairSweep.rotation.x = -0.6; // Even more swept up
        this.characterGroup.add(hairSweep);

        // Hair sides - shorter and more styled
        const hairSideGeometry = createBoxGeometry(0.08, 0.28, 0.32);
        const leftHairSide = new THREE.Mesh(hairSideGeometry, hairMaterial);
        leftHairSide.position.set(-0.17, 1.48, 0);
        leftHairSide.rotation.z = 0.1; // Slight inward angle
        this.characterGroup.add(leftHairSide);

        const rightHairSide = new THREE.Mesh(hairSideGeometry, hairMaterial);
        rightHairSide.position.set(0.17, 1.48, 0);
        rightHairSide.rotation.z = -0.1; // Slight inward angle
        this.characterGroup.add(rightHairSide);

        // Hair back - more styled
        const hairBackGeometry = createBoxGeometry(0.34, 0.28, 0.12);
        const hairBack = new THREE.Mesh(hairBackGeometry, hairMaterial);
        hairBack.position.set(0, 1.48, -0.15);
        this.characterGroup.add(hairBack);
        
        // Arms - adjusted proportions
        const armGeometry = createBoxGeometry(0.15, 0.6, 0.15); // Thinner arms
        const armMaterial = createStandardMaterial(0x000000, 0.9);
        
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.32, 0.6, 0);
        leftArm.rotation.z = 0.1;
        leftArm.name = 'leftArm';
        this.leftArm = leftArm; // Store reference
        this.characterGroup.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.32, 0.6, 0);
        rightArm.rotation.z = -0.1;
        rightArm.name = 'rightArm';
        this.rightArm = rightArm; // Store reference
        this.characterGroup.add(rightArm);
        
        // Legs - skinny jeans style
        const legGeometry = createBoxGeometry(0.18, 0.7, 0.18); // Thinner legs
        const legMaterial = createStandardMaterial(0x000000, 0.9);
        
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-0.12, -0.15, 0);
        leftLeg.rotation.x = 0.1;
        leftLeg.name = 'leftLeg';
        this.leftLeg = leftLeg; // Store reference
        this.characterGroup.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0.12, -0.15, 0);
        rightLeg.rotation.x = -0.1;
        rightLeg.name = 'rightLeg';
        this.rightLeg = rightLeg; // Store reference
        this.characterGroup.add(rightLeg);
        
        // Shoes - detailed sneaker style
        const createSneaker = (isLeft) => {
            const sneakerGroup = new THREE.Group();
            
            // Main shoe body
            const upperGeometry = createBoxGeometry(0.25, 0.15, 0.4); // Smaller sneakers
            const upperMaterial = createStandardMaterial(0x000000, 0.9);
            const upper = new THREE.Mesh(upperGeometry, upperMaterial);
            upper.position.set(0, 0.05, 0);
            sneakerGroup.add(upper);
            
            // Sole
            const soleGeometry = createBoxGeometry(0.28, 0.1, 0.42); // Adjusted sole
            const soleMaterial = createStandardMaterial(0xFFFFFF, 0.9);
            const sole = new THREE.Mesh(soleGeometry, soleMaterial);
            sole.position.set(0, -0.05, 0);
            sneakerGroup.add(sole);
            
            // Laces
            const laceGeometry = createBoxGeometry(0.22, 0.02, 0.02); // Thinner laces
            const laceMaterial = createStandardMaterial(0xFFFFFF, 0.9);
            for (let i = 0; i < 3; i++) {
                const lace = new THREE.Mesh(laceGeometry, laceMaterial);
                lace.position.set(0, 0.08 + (i * 0.03), 0.2);
                lace.rotation.x = -0.1;
                sneakerGroup.add(lace);
            }

            // Tongue
            const tongueGeometry = createBoxGeometry(0.18, 0.1, 0.05);
            const tongueMaterial = createStandardMaterial(0x333333, 0.9);
            const tongue = new THREE.Mesh(tongueGeometry, tongueMaterial);
            tongue.position.set(0, 0.12, 0.16); 
            tongue.rotation.x = -0.5;
            sneakerGroup.add(tongue);
            
            // Heel tab
            const heelGeometry = createBoxGeometry(0.15, 0.1, 0.05);
            const heelMaterial = createStandardMaterial(0x444444, 0.9);
            const heel = new THREE.Mesh(heelGeometry, heelMaterial);
            heel.position.set(0, 0.1, -0.2);
            heel.rotation.x = 0.3;
            sneakerGroup.add(heel);
            
            return sneakerGroup;
        };

        this.leftShoe = createSneaker(true);
        this.leftShoe.position.set(-0.12, -0.7, 0.1);
        this.leftShoe.rotation.x = 0.1;
        this.leftShoe.name = 'leftShoe';
        this.characterGroup.add(this.leftShoe);

        this.rightShoe = createSneaker(false);
        this.rightShoe.position.set(0.12, -0.7, 0.1);
        this.rightShoe.rotation.x = -0.1;
        this.rightShoe.name = 'rightShoe';
        this.characterGroup.add(this.rightShoe);
        
        // Add character to scene with adjusted base height
        this.characterGroup.position.set(0, 1.1, 0);
    }

    setupState() {
        this.characterState = {
            x: this.characterGroup.position.x,
            y: this.characterGroup.position.y,
            z: this.characterGroup.position.z,
            rotation: 0,
            moveSpeed: 5,
            jumpForce: 8,
            gravity: -15,
            velocity: new THREE.Vector3(),
            isJumping: false,
            jumpVelocity: 0,
            baseY: 1.0, // Ground level
            // Animation states
            walkTime: 0,
            walkSpeed: 10,
            walkAmplitude: 0.3,
            isWalking: false,
            isIdle: true,
            idleAnimationTime: Math.random() * Math.PI * 2, 
            idleAnimationSpeed: 0.5 + Math.random() * 0.5,
            shouldWaveArm: false, // Controlled by NPC logic or player input if desired
        };

        // Store references to legs and arms for animation
        this.leftLeg = this.characterGroup.getObjectByName('leftLeg');
        this.rightLeg = this.characterGroup.getObjectByName('rightLeg');
        this.leftArm = this.characterGroup.getObjectByName('leftArm');
        this.rightArm = this.characterGroup.getObjectByName('rightArm');
        this.leftShoe = this.characterGroup.children.find(child => 
            child.isGroup && child.position.x < 0);
        this.rightShoe = this.characterGroup.children.find(child => 
            child.isGroup && child.position.x > 0);

        // REMOVED: Add character to scene with adjusted base height
        // this.characterGroup.position.set(0, 1.1, 0); 
    }

    // Helper method to get the character's AABB
    getAABB() {
        if (!this._aabb) {
            this._aabb = new THREE.Box3();
        }
        // Calculate AABB from the entire character group for better accuracy
        this._aabb.setFromObject(this.characterGroup, true); // Use precise option

        // Optional: Expand the box slightly for safety margin
        // this._aabb.expandByScalar(0.1);
        return this._aabb;
    }
    
    update(deltaTime, keys, camera, obstacles = [], portals = []) {
        // --- Player Input Processing --- 
        const moveDirection = new THREE.Vector3(0, 0, 0);
        let isPlayerMoving = false; // Use a local variable for input check
        let playerWantsToShoot = false;

        // Check movement keys (Only apply if this instance is player-controlled - NPCs pass empty keys)
        if (keys['ArrowUp']) {
            moveDirection.z -= 1;
            isPlayerMoving = true;
        }
        if (keys['ArrowDown']) {
            moveDirection.z += 1;
            isPlayerMoving = true;
        }
        if (keys['ArrowLeft']) {
            moveDirection.x -= 1;
            isPlayerMoving = true;
        }
        if (keys['ArrowRight']) {
            moveDirection.x += 1;
            isPlayerMoving = true;
        }

        // Check shoot key
        const now = performance.now() / 1000;
        if (keys['KeyE'] && (now - this.lastShootTime > this.shootCooldown)) {
             playerWantsToShoot = true;
        }

        // --- Update Velocity based on Input (if player) --- 
        if (Object.keys(keys).length > 0) { // Assume player if keys are passed
            if (isPlayerMoving) {
                moveDirection.normalize();
                const moveVelocity = moveDirection.multiplyScalar(this.characterState.moveSpeed);
                // Smoothly interpolate horizontal velocity
                this.characterState.velocity.x = THREE.MathUtils.lerp(this.characterState.velocity.x, moveVelocity.x, 0.1);
                this.characterState.velocity.z = THREE.MathUtils.lerp(this.characterState.velocity.z, moveVelocity.z, 0.1);
                 // Update rotation based on input direction
                 this.characterState.rotation = Math.atan2(moveDirection.x, moveDirection.z);
                 this.characterGroup.rotation.y = this.characterState.rotation;
            } else {
                 // Smoothly dampen horizontal velocity if no movement input
                 this.characterState.velocity.x = THREE.MathUtils.lerp(this.characterState.velocity.x, 0, 0.1);
                 this.characterState.velocity.z = THREE.MathUtils.lerp(this.characterState.velocity.z, 0, 0.1);
            }
            
            // Set animation state flags based on player input
             this.characterState.isWalking = isPlayerMoving && !this.characterState.isJumping;
             this.characterState.isIdle = !isPlayerMoving && !this.characterState.isJumping;

             // Handle Shooting based on input
              if (playerWantsToShoot) {
                  this.lastShootTime = now;
                  this.shootVinyl();
                  if (this.chatSystem) { 
                      this.chatSystem.addPlayerMessage("Flinging a disc!");
                  } else {
                      console.warn("Character: chatSystem not available to send message.");
                  }
             }
        } 
        // ELSE: If no keys are passed (NPC call), assume velocity/rotation/state is handled externally
        
        // --- Apply Gravity (Applies to both Player and NPC) --- 
        if (this.characterState.isJumping) {
            this.characterState.jumpVelocity += this.characterState.gravity * deltaTime;
            this.characterState.velocity.y = this.characterState.jumpVelocity;
        } else {
            // Apply a small downward force when on ground to ensure contact/trigger landing
            this.characterState.velocity.y = -1; 
        }

        // --- Collision Detection and Resolution (Applies to both Player and NPC) --- 
        const currentPosition = this.characterGroup.position.clone();
        // Use the current velocity (set by player input or NPC logic)
        let proposedPosition = currentPosition.clone().add(this.characterState.velocity.clone().multiplyScalar(deltaTime)); 
        
        let collisionOccurred = false;
        let verticalCollision = false;
        let landedThisFrame = false;

        // Define character collision dimensions
        const characterHeight = 1.8; // Approximate height
        const characterWidth = 0.6; // Approximate width/depth

        obstacles.forEach(obstacle => {
             // Get the character's base AABB for size reference if needed later, but don't use it directly for the check AABB
             // const baseCharacterAABB = this.getAABB(); 

             // --- Calculate AABB from Bottom-Center and Size --- 
             // Align bottom of collision box with proposed foot position
             const checkCenterX = proposedPosition.x;
             const checkCenterZ = proposedPosition.z;
             const collisionMin = new THREE.Vector3(checkCenterX - characterWidth / 2, proposedPosition.y, checkCenterZ - characterWidth / 2);
             const collisionMax = new THREE.Vector3(checkCenterX + characterWidth / 2, proposedPosition.y + characterHeight, checkCenterZ + characterWidth / 2);
             const collisionCheckAABB = new THREE.Box3(collisionMin, collisionMax);
             // --- End AABB Calculation --- 

             // --- DEBUG: Check AABB values for ALL obstacles ---
            // console.log(`Checking collision with ${obstacle.object.name || obstacle.object.type} at Pos: ${obstacle.object.position.x.toFixed(1)},${obstacle.object.position.y.toFixed(1)},${obstacle.object.position.z.toFixed(1)}`);
            // console.log(`  Character AABB: ${collisionCheckAABB.min.x.toFixed(2)}, ${collisionCheckAABB.min.y.toFixed(2)}, ${collisionCheckAABB.min.z.toFixed(2)} -> ${collisionCheckAABB.max.x.toFixed(2)}, ${collisionCheckAABB.max.y.toFixed(2)}, ${collisionCheckAABB.max.z.toFixed(2)}`);
            // console.log(`  Obstacle AABB: ${obstacle.aabb.min.x.toFixed(2)}, ${obstacle.aabb.min.y.toFixed(2)}, ${obstacle.aabb.min.z.toFixed(2)} -> ${obstacle.aabb.max.x.toFixed(2)}, ${obstacle.aabb.max.y.toFixed(2)}, ${obstacle.aabb.max.z.toFixed(2)}`);
            // const intersects = collisionCheckAABB.intersectsBox(obstacle.aabb);
            // console.log(`  Intersection: ${intersects}`);
             // --- END DEBUG ---

             if (collisionCheckAABB.intersectsBox(obstacle.aabb)) {
                 collisionOccurred = true;
                 const obstacleName = obstacle.object.name || obstacle.object.type;
                 console.log(`COLLISION DETECTED with ${obstacleName}`); // Log collision
                 console.log(`  Before Resolve - Proposed Pos: ${proposedPosition.x.toFixed(2)}, ${proposedPosition.y.toFixed(2)}, ${proposedPosition.z.toFixed(2)}`);

                 // Resolve Y collision first
                 // Recalculate AABB based on Y-only movement for Y check
                 const yCheckCenter = currentPosition.clone();
                 yCheckCenter.y = proposedPosition.y + (characterHeight / 2);
                 const tempAABB_Y = new THREE.Box3().setFromCenterAndSize(yCheckCenter, new THREE.Vector3(characterWidth, characterHeight, characterWidth));
                 if (tempAABB_Y.intersectsBox(obstacle.aabb)) {
                      verticalCollision = true;
                      if (this.characterState.velocity.y <= 0) { // Moving down
                           landedThisFrame = true;
                           this.characterState.isJumping = false;
                           this.characterState.jumpVelocity = 0;
                           this.characterState.velocity.y = 0;
                           // Reset position based on the simplified collision box bottom
                           proposedPosition.y = obstacle.aabb.max.y; // Foot level at top of obstacle
                           this.characterState.baseY = proposedPosition.y;
                      } else { // Moving up (Hit head)
                           this.characterState.jumpVelocity = 0;
                           this.characterState.velocity.y = 0;
                           // Reset position based on the simplified collision box top
                           proposedPosition.y = obstacle.aabb.min.y - characterHeight - 0.01; // Head below obstacle bottom
                      }
                 }

                 // Get character AABB size for resolution (use defined width)
                 const characterSize = new THREE.Vector3(characterWidth, characterHeight, characterWidth);
                 // const characterSize = baseCharacterAABB.getSize(new THREE.Vector3());

                 // Resolve X collision if no vertical collision resolved movement
                 // Recalculate AABB based on X-only movement
                 const xCheckCenter = currentPosition.clone();
                 xCheckCenter.x = proposedPosition.x;
                 xCheckCenter.y += characterHeight / 2; 
                 const tempAABB_X = new THREE.Box3().setFromCenterAndSize(xCheckCenter, characterSize);
                 if (tempAABB_X.intersectsBox(obstacle.aabb)) {
                     this.characterState.velocity.x = 0;
                     if (proposedPosition.x > currentPosition.x) { // Moving right (+X)
                          proposedPosition.x = obstacle.aabb.min.x - (characterSize.x / 2) - 0.01;
                     } else { // Moving left (-X)
                          proposedPosition.x = obstacle.aabb.max.x + (characterSize.x / 2) + 0.01;
                     }
                 }

                 // Resolve Z collision if no vertical collision resolved movement
                 // Recalculate AABB based on Z-only movement
                 const zCheckCenter = currentPosition.clone();
                 zCheckCenter.z = proposedPosition.z;
                 zCheckCenter.y += characterHeight / 2; 
                 const tempAABB_Z = new THREE.Box3().setFromCenterAndSize(zCheckCenter, characterSize);
                 if (tempAABB_Z.intersectsBox(obstacle.aabb)) {
                     this.characterState.velocity.z = 0;
                     if (proposedPosition.z > currentPosition.z) { // Moving forward (+Z)
                          proposedPosition.z = obstacle.aabb.min.z - (characterSize.z / 2) - 0.01;
                     } else { // Moving backward (-Z)
                          proposedPosition.z = obstacle.aabb.max.z + (characterSize.z / 2) + 0.01;
                     }
                 }
                 console.log(`  After Resolve - Proposed Pos: ${proposedPosition.x.toFixed(2)}, ${proposedPosition.y.toFixed(2)}, ${proposedPosition.z.toFixed(2)}`); // Log resolved position
             }
        });

        // Apply the potentially adjusted proposed position
        this.characterGroup.position.copy(proposedPosition);

        // Final ground check / prevent falling through floor
        // Use baseY determined by collision or default
        if (this.characterGroup.position.y < this.characterState.baseY && !this.characterState.isJumping && !verticalCollision) {
            this.characterGroup.position.y = this.characterState.baseY;
            this.characterState.velocity.y = 0;
            if (this.characterState.isJumping) { // Landed on ground
                 landedThisFrame = true; 
                 this.characterState.isJumping = false;
                 this.characterState.jumpVelocity = 0;
            }
        }
        
        // Update internal state position from final group position
        this.characterState.x = this.characterGroup.position.x;
        this.characterState.y = this.characterGroup.position.y;
        this.characterState.z = this.characterGroup.position.z;
        
        // --- Update Animations (Based on current state flags) --- 
        // State flags (isWalking, isIdle) are now set EITHER by player input OR by NPC logic before super.update()
        if (this.characterState.isWalking) {
            this.characterState.walkTime += deltaTime * this.characterState.walkSpeed;
            this.animateWalk(this.characterState.walkTime, this.characterState.walkAmplitude);
        } else if (this.characterState.isIdle) {
             // Reset walk time when starting idle?
             // this.characterState.walkTime = 0;
            this.characterState.idleAnimationTime += deltaTime * this.characterState.idleAnimationSpeed;
            // Use the shouldWaveArm state which might be set by NPC
            this.animateIdle(this.characterState.idleAnimationTime, this.characterState.shouldWaveArm); 
        } else { // Jumping or falling
            this.setNeutralPose(); // Or a specific jump/fall pose
        }

        // --- Update Vinyls (Applies to Player only, NPCs don't shoot) --- 
         if (Object.keys(keys).length > 0) { // Only update vinyls for player character
             for (let i = this.vinyls.length - 1; i >= 0; i--) {
                 const vinyl = this.vinyls[i];
                 vinyl.update(deltaTime);
                 if (!vinyl.isActive) {
                     this.scene.remove(vinyl.mesh);
                     this.vinyls.splice(i, 1);
                 }
             }
         }
        
        // --- Update Speech Bubble (Applies to both Player and NPC) --- 
        if (this.activeSpeechBubble && camera) {
             const headPosition = this.characterGroup.position.clone();
             headPosition.y += 1.8; // Adjust height offset
             this.activeSpeechBubble.update(headPosition, camera);
        }
    }

    // --- Animation Methods --- 

    animateWalk(walkTime, amplitude) {
        if (this.leftArm && this.rightArm) {
            const armAngle = Math.sin(walkTime) * amplitude * 0.7;
            this.leftArm.rotation.x = -armAngle;
            this.rightArm.rotation.x = armAngle;
            this.leftArm.rotation.z = 0.15 + Math.sin(walkTime) * 0.1; // Side swing
            this.rightArm.rotation.z = -0.15 - Math.sin(walkTime) * 0.1;
        }
        if (this.leftLeg && this.rightLeg) {
            const legAngle = Math.sin(walkTime) * amplitude;
            this.leftLeg.rotation.x = legAngle + 0.1;
            this.rightLeg.rotation.x = -legAngle - 0.1;
            // Subtle up/down motion for legs
            this.leftLeg.position.y = -0.15 + Math.abs(Math.sin(walkTime)) * 0.05;
            this.rightLeg.position.y = -0.15 + Math.abs(Math.sin(walkTime + Math.PI)) * 0.05;
        }
         if (this.leftShoe && this.rightShoe) {
            const legAngle = Math.sin(walkTime) * amplitude;
            this.leftShoe.rotation.x = legAngle + 0.1;
            this.rightShoe.rotation.x = -legAngle - 0.1;
            // Match shoe position y to leg position y
            this.leftShoe.position.y = -0.7 + Math.abs(Math.sin(walkTime)) * 0.05;
            this.rightShoe.position.y = -0.7 + Math.abs(Math.sin(walkTime + Math.PI)) * 0.05;
            // Add z movement for shoes
            this.leftShoe.position.z = 0.1 + Math.sin(walkTime) * 0.1;
            this.rightShoe.position.z = 0.1 + Math.sin(walkTime + Math.PI) * 0.1;
        }
    }

    animateIdle(idleTime, shouldWave) {
         if (this.leftArm && this.rightArm) {
             if (shouldWave) {
                 // Wave animation for right arm (example)
                 const waveAngle = Math.sin(idleTime * 2) * 0.8; // Faster, wider wave
                 this.rightArm.rotation.z = -0.15 - waveAngle;
                 this.rightArm.rotation.x = -0.5 + Math.sin(idleTime) * 0.3;
                 // Keep left arm relatively still
                 this.leftArm.rotation.x = Math.sin(idleTime * 0.5) * 0.05;
                 this.leftArm.rotation.z = 0.15;
             } else {
                 // Subtle breathing/idle movement
                 const idleAngle = Math.sin(idleTime * 0.5) * 0.05; 
                 this.leftArm.rotation.x = idleAngle;
                 this.rightArm.rotation.x = -idleAngle;
                 this.leftArm.rotation.z = 0.15 + Math.sin(idleTime * 0.3) * 0.03; // Very subtle side sway
                 this.rightArm.rotation.z = -0.15 - Math.sin(idleTime * 0.3) * 0.03;
             }
         }
         // Keep legs relatively still during idle
         if (this.leftLeg && this.rightLeg) {
            this.leftLeg.rotation.x = 0.1;
            this.rightLeg.rotation.x = -0.1;
            this.leftLeg.position.y = -0.15;
            this.rightLeg.position.y = -0.15;
        }
        if (this.leftShoe && this.rightShoe) {
            this.leftShoe.rotation.x = 0.1;
            this.rightShoe.rotation.x = -0.1;
            this.leftShoe.position.y = -0.7;
            this.rightShoe.position.y = -0.7;
            this.leftShoe.position.z = 0.1;
            this.rightShoe.position.z = 0.1;
        }
    }

    setNeutralPose() {
        // Reset arms and legs to a neutral position (e.g., slightly bent)
        if (this.leftArm) this.leftArm.rotation.set(0, 0, 0.1);
        if (this.rightArm) this.rightArm.rotation.set(0, 0, -0.1);
        if (this.leftLeg) {
             this.leftLeg.rotation.set(0.1, 0, 0);
             this.leftLeg.position.y = -0.15;
        }
        if (this.rightLeg) {
            this.rightLeg.rotation.set(-0.1, 0, 0);
            this.rightLeg.position.y = -0.15;
        }
        if (this.leftShoe) {
            this.leftShoe.rotation.set(0.1, 0, 0);
            this.leftShoe.position.y = -0.7;
            this.leftShoe.position.z = 0.1;
        }
         if (this.rightShoe) {
            this.rightShoe.rotation.set(-0.1, 0, 0);
            this.rightShoe.position.y = -0.7;
            this.rightShoe.position.z = 0.1;
        }
    }

    // --- Other Methods --- 

    shootVinyl() {
        const direction = new THREE.Vector3();
        this.characterGroup.getWorldDirection(direction);
        
        // Spawn vinyl slightly in front of character
        const spawnOffset = direction.clone().multiplyScalar(0.5);
        const spawnPosition = this.characterGroup.position.clone().add(spawnOffset);
        spawnPosition.y += 1.0; // Adjust vertical spawn height

        const vinyl = new Vinyl(this.scene, spawnPosition, direction);
        this.vinyls.push(vinyl);
        
        console.log("Shot vinyl!");
        // Potentially add sound effect here
    }

    getPosition() {
        return this.characterGroup.position.clone();
    }
    
    say(message) {
        // Remove existing speech bubble if any
        if (this.activeSpeechBubble) {
            this.activeSpeechBubble.remove();
        }
        
        // Create a new speech bubble with correct argument order
        this.activeSpeechBubble = new SpeechBubble(this.scene, message); 
        // Initial position update will happen in the update loop
    }
} 
```

```
// js/chat.js
export class ChatSystem {
    constructor(playerCharacter) {
        // Get references to UI elements created in index.html
        this.container = document.getElementById('chat-container');
        this.messageList = document.getElementById('chat-messages');
        this.inputField = document.getElementById('chat-input');
        this.submitButton = document.getElementById('chat-submit');

        this.playerCharacter = playerCharacter;

        if (!this.container || !this.messageList || !this.inputField || !this.submitButton) {
            console.error("Chat UI elements (container, messages, input, or submit) not found in the DOM!");
            // Optionally, create them here as a fallback, but ideally they exist in HTML
            this.setupUIFallback(); 
        } else {
            this.setupEventListeners();
        }

        // No character reference needed here anymore
        // No message lifetime/fading needed for now
        // No style setup needed (handled by style.css)
    }

    // Fallback in case HTML elements are missing
    setupUIFallback() {
        console.warn("Creating fallback chat UI elements.");
        if (!this.container) {
            this.container = document.createElement('div');
            this.container.id = 'chat-container';
            document.body.appendChild(this.container);
        }
        if (!this.messageList) {
            this.messageList = document.createElement('ul');
            this.messageList.id = 'chat-messages';
            this.container.appendChild(this.messageList);
            // Apply basic styles if needed, though style.css should handle it
            this.container.style.position = 'fixed'; 
            this.container.style.bottom = '20px';
            this.container.style.left = '20px';
            this.container.style.width = '350px';
            this.container.style.maxHeight = '200px';
             this.container.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            this.container.style.border = '1px solid #00ff00';
            this.messageList.style.listStyle = 'none';
            this.messageList.style.padding = '5px 10px';
            this.messageList.style.margin = '0';
            this.messageList.style.overflowY = 'auto';
             this.messageList.style.height = 'calc(100% - 30px)'; // Adjust height for input
        }
    }

    // Setup event listeners for input
    setupEventListeners() {
        this.submitButton.addEventListener('click', () => this.submitMessage());
        this.inputField.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default form submission or line breaks
                this.submitMessage();
            }
        });
    }

    // Logic to handle message submission
    submitMessage() {
        const messageText = this.inputField.value.trim();
        if (messageText && this.playerCharacter) {
            // Call say() on player character for bubble
            this.playerCharacter.say(messageText);
            // ALSO add to chat log
            this.addPlayerMessage(messageText);
            this.inputField.value = ''; // Clear the input field
            // Optional: Refocus input field after sending
            // this.inputField.focus(); 
        }
    }

    // Generic message adder
    addMessage(text, senderType, senderName = null) {
        if (!this.messageList) {
            console.error("Message list element not found.");
            return;
        }

        const messageElement = document.createElement('li');
        let displayText = text;
        let cssClass = 'message-' + senderType;

        // Add sender name prefix for NPCs
        if (senderType === 'npc' && senderName) {
            displayText = `<span class="sender-name">${senderName}:</span> ${text}`;
        } 
        // Add generic prefix for player (can customize later)
        else if (senderType === 'player') {
            displayText = `<span class="sender-name">Player:</span> ${text}`; // Simple prefix
        }

        messageElement.classList.add(cssClass);
        messageElement.innerHTML = displayText; // Use innerHTML to render the span

        this.messageList.appendChild(messageElement);

        // Auto-scroll to the bottom
        this.messageList.scrollTop = this.messageList.scrollHeight;
    }

    // Specific message types
    addSystemMessage(text) {
        this.addMessage(text, 'system');
    }

    addPlayerMessage(text) {
        this.addMessage(text, 'player');
    }

    addNPCMessage(name, text) {
        this.addMessage(text, 'npc', name);
    }

    // Removed update method and fading logic
    // Removed setupStyles
    // Removed setupEventListeners (now part of constructor check)
    // Removed submitMessage (re-added above)
} 
```

```
// import * as THREE from 'three';
import { createStandardMaterial, createBoxGeometry, createCylinderGeometry, createSphereGeometry, createPlaneGeometry } from './utils.js';

export class DecorativeElements {
    constructor(scene) {
        this.scene = scene;
        this.createDecorations();
    }

    createDecorations() {
        // Create decorative group
        this.decorativeGroup = new THREE.Group();
        
        // Add benches along the pier
        this.addBenches();
        
        // Add trash bins
        this.addTrashBins();
        
        // Add lamp posts
        this.addLampPosts();
        
        // Add the scene
        this.scene.add(this.decorativeGroup);
    }

    addBenches() {
        const benchMaterial = createStandardMaterial(0x8B4513, 0.7, 0.2);
        
        // Create bench geometry
        const benchGeometry = createBoxGeometry(2, 0.4, 0.5);
        const benchBackGeometry = createBoxGeometry(2, 0.8, 0.1);
        
        // Add benches along the pier
        const benchPositions = [
            [-15, 0.2, 8], [-5, 0.2, 8], [5, 0.2, 8], [15, 0.2, 8],
            [-15, 0.2, -8], [-5, 0.2, -8], [5, 0.2, -8], [15, 0.2, -8]
        ];
        
        benchPositions.forEach(pos => {
            const bench = new THREE.Group();
            
            // Bench seat
            const seat = new THREE.Mesh(benchGeometry, benchMaterial);
            seat.position.set(0, 0.2, 0);
            bench.add(seat);
            
            // Bench back
            const back = new THREE.Mesh(benchBackGeometry, benchMaterial);
            back.position.set(0, 0.6, -0.2);
            bench.add(back);
            
            // Bench legs
            const legGeometry = createBoxGeometry(0.1, 0.4, 0.1);
            const legMaterial = createStandardMaterial(0x6B3E14, 0.8);
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.9, 0, 0);
            bench.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.9, 0, 0);
            bench.add(rightLeg);
            
            bench.position.set(pos[0], pos[1], pos[2]);
            bench.userData.isCollidable = true;
            this.decorativeGroup.add(bench);
        });
    }

    addTrashBins() {
        const binMaterial = createStandardMaterial(0x333333, 0.8);
        const binGeometry = createBoxGeometry(0.4, 0.8, 0.4);
        
        const binPositions = [
            [-18, 0.4, 8], [-8, 0.4, 8], [8, 0.4, 8], [18, 0.4, 8],
            [-18, 0.4, -8], [-8, 0.4, -8], [8, 0.4, -8], [18, 0.4, -8]
        ];
        
        binPositions.forEach(pos => {
            const bin = new THREE.Mesh(binGeometry, binMaterial);
            bin.position.set(pos[0], pos[1], pos[2]);
            this.decorativeGroup.add(bin);
        });
    }

    addLampPosts() {
        const lampMaterial = createStandardMaterial(0xCCCCCC, 0.8);
        const lampLightMaterial = createStandardMaterial(0xFFFF00, 0.5, 0.8, 0xFFFF00, 0.5);
        
        const lampPositions = [
            [-15, 0, 9], [-5, 0, 9], [5, 0, 9], [15, 0, 9],
            [-15, 0, -9], [-5, 0, -9], [5, 0, -9], [15, 0, -9]
        ];
        
        lampPositions.forEach(pos => {
            const lamp = new THREE.Group();
            
            // Lamp post
            const post = new THREE.Mesh(createBoxGeometry(0.1, 2, 0.1), lampMaterial);
            post.position.set(0, 1, 0);
            lamp.add(post);
            
            // Lamp head
            const head = new THREE.Mesh(createBoxGeometry(0.4, 0.1, 0.4), lampMaterial);
            head.position.set(0, 2, 0);
            lamp.add(head);
            
            // Lamp light
            const light = new THREE.Mesh(createBoxGeometry(0.3, 0.1, 0.3), lampLightMaterial);
            light.position.set(0, 2.05, 0);
            lamp.add(light);
            
            lamp.position.set(pos[0], pos[1], pos[2]);
            this.decorativeGroup.add(lamp);
        });
    }

    addPalmTree(x, y, z) {
        const palmGroup = new THREE.Group();
        
        // Trunk
        const trunkGeometry = createCylinderGeometry(0.1, 0.15, 2, 8);
        const trunkMaterial = createStandardMaterial(0x8B4513, 0.8);
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 1;
        palmGroup.add(trunk);
        
        // Leaves
        const leafMaterial = createStandardMaterial(0x00AA00, 0.7, 0.2, 0x003300, 0.2);
        
        for (let i = 0; i < 5; i++) {
            const leafGeometry = createBoxGeometry(0.8, 0.05, 0.3);
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.y = 2;
            leaf.rotation.y = (i / 5) * Math.PI * 2;
            leaf.rotation.x = -0.2;
            leaf.position.x = Math.sin(leaf.rotation.y) * 0.5;
            leaf.position.z = Math.cos(leaf.rotation.y) * 0.5;
            palmGroup.add(leaf);
        }
        
        palmGroup.position.set(x, y, z);
        this.scene.add(palmGroup);
    }

    addBeachChair(x, y, z) {
        const chairGroup = new THREE.Group();
        
        // Chair base
        const baseGeometry = createBoxGeometry(0.8, 0.1, 1.5);
        const chairMaterial = createStandardMaterial(0xFFD700, 0.5, 0.2, 0x332200, 0.1);
        const base = new THREE.Mesh(baseGeometry, chairMaterial);
        base.position.y = 0.05;
        chairGroup.add(base);
        
        // Chair back
        const backGeometry = createBoxGeometry(0.8, 0.8, 0.1);
        const back = new THREE.Mesh(backGeometry, chairMaterial);
        back.position.set(0, 0.4, -0.7);
        back.rotation.x = Math.PI / 6;
        chairGroup.add(back);
        
        chairGroup.position.set(x, y, z);
        this.scene.add(chairGroup);
    }

    addKiosk(x, y, z) {
        const kioskGroup = new THREE.Group();
        
        // Kiosk base
        const baseGeometry = createBoxGeometry(2, 1.5, 1.5);
        const baseMaterial = createStandardMaterial(0x1E90FF, 0.5, 0.2, 0x001133, 0.2);
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.75;
        kioskGroup.add(base);
        
        // Kiosk roof
        const roofGeometry = createBoxGeometry(2.4, 0.1, 1.9);
        const roofMaterial = createStandardMaterial(0xFF6347, 0.7, 0.2, 0x330000, 0.1);
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.y = 1.55;
        kioskGroup.add(roof);
        
        // Counter
        const counterGeometry = createBoxGeometry(2, 0.1, 0.5);
        const counterMaterial = createStandardMaterial(0xDEB887, 0.6);
        const counter = new THREE.Mesh(counterGeometry, counterMaterial);
        counter.position.set(0, 1, 0.8);
        kioskGroup.add(counter);
        
        kioskGroup.position.set(x, y, z);
        this.scene.add(kioskGroup);
    }

    addBoat(x, y, z) {
        const boatGroup = new THREE.Group();
        
        // Boat hull
        const hullGeometry = createBoxGeometry(2, 0.5, 1);
        const hullMaterial = createStandardMaterial(0x964B00, 0.7);
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);
        hull.position.y = 0.25;
        boatGroup.add(hull);
        
        // Boat interior
        const interiorGeometry = createBoxGeometry(1.8, 0.2, 0.8);
        const interiorMaterial = createStandardMaterial(0xDEB887, 0.6);
        const interior = new THREE.Mesh(interiorGeometry, interiorMaterial);
        interior.position.y = 0.4;
        boatGroup.add(interior);
        
        boatGroup.position.set(x, y, z);
        this.scene.add(boatGroup);
    }

    addFishingSpot(x, y, z) {
        const fishingGroup = new THREE.Group();
        
        // Fishing rod
        const rodGeometry = createCylinderGeometry(0.02, 0.02, 1.5, 8);
        const rodMaterial = createStandardMaterial(0x8B4513, 0.8);
        const rod = new THREE.Mesh(rodGeometry, rodMaterial);
        rod.position.y = 0.75;
        rod.rotation.x = -Math.PI / 4;
        rod.rotation.z = Math.PI / 10;
        fishingGroup.add(rod);
        
        // Fishing line
        const lineGeometry = new THREE.BufferGeometry();
        const linePoints = [
            new THREE.Vector3(0, 1.5, -0.75),
            new THREE.Vector3(0.2, 0.5, -1.5),
            new THREE.Vector3(0.2, 0, -1.5)
        ];
        lineGeometry.setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        fishingGroup.add(line);
        
        fishingGroup.position.set(x, y, z);
        this.scene.add(fishingGroup);
    }

    addBeachBall(x, y, z) {
        const ballGeometry = createSphereGeometry(0.3, 16, 16);
        const ballMaterial = createStandardMaterial(0xFF6347, 0.4, 0.2, 0x330000, 0.1);
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(x, y + 0.3, z);
        this.scene.add(ball);
        
        // Store for animation
        this.beachBall = ball;
    }

    addNeonSign(x, y, z, text, color) {
        const signGroup = new THREE.Group();
        
        // Sign background
        const backGeometry = createBoxGeometry(text.length * 0.5, 0.8, 0.1);
        const backMaterial = createStandardMaterial(0x111111, 0.9, 0.2);
        const back = new THREE.Mesh(backGeometry, backMaterial);
        signGroup.add(back);
        
        // Create neon text effect with small cubes
        const textGroup = new THREE.Group();
        const cubeSize = 0.1;
        const letterSpacing = 0.25;
        const startX = -(text.length - 1) * letterSpacing / 2;
        
        // Simple pixel font patterns for each letter
        const patterns = {
            'P': [
                [1,1,1],
                [1,0,1],
                [1,1,1],
                [1,0,0],
                [1,0,0]
            ],
            'I': [
                [1,1,1],
                [0,1,0],
                [0,1,0],
                [0,1,0],
                [1,1,1]
            ],
            'E': [
                [1,1,1],
                [1,0,0],
                [1,1,1],
                [1,0,0],
                [1,1,1]
            ],
            'R': [
                [1,1,1],
                [1,0,1],
                [1,1,1],
                [1,0,1],
                [1,0,1]
            ],
            'B': [
                [1,1,0],
                [1,0,1],
                [1,1,0],
                [1,0,1],
                [1,1,0]
            ],
            'O': [
                [1,1,1],
                [1,0,1],
                [1,0,1],
                [1,0,1],
                [1,1,1]
            ],
            'Y': [
                [1,0,1],
                [1,0,1],
                [0,1,0],
                [0,1,0],
                [0,1,0]
            ]
        };
        
        const cubeMaterial = createStandardMaterial(color, 0.3, 0.8, color, 1);
        
        for (let i = 0; i < text.length; i++) {
            const letter = text[i];
            const pattern = patterns[letter];
            
            if (pattern) {
                for (let row = 0; row < pattern.length; row++) {
                    for (let col = 0; col < pattern[row].length; col++) {
                        if (pattern[row][col]) {
                            const cube = new THREE.Mesh(
                                createBoxGeometry(cubeSize, cubeSize, cubeSize),
                                cubeMaterial
                            );
                            cube.position.set(
                                startX + i * letterSpacing + (col - 1) * cubeSize,
                                0.2 - row * cubeSize,
                                0.1
                            );
                            textGroup.add(cube);
                        }
                    }
                }
            }
        }
        
        signGroup.add(textGroup);
        signGroup.position.set(x, y, z);
        signGroup.rotation.y = Math.PI;
        this.scene.add(signGroup);
    }

    update(deltaTime) {
        // Animate beach ball
        if (this.beachBall) {
            const time = Date.now() * 0.001;
            this.beachBall.position.y = 0.3 + Math.sin(time * 2) * 0.05;
            this.beachBall.rotation.y += deltaTime;
        }
    }
} 
```

```
// js/decorative.js
import * as THREE from 'three';
import { createStandardMaterial, createBoxGeometry, createCylinderGeometry, createSphereGeometry, createPlaneGeometry } from './utils.js';

export class DecorativeElements {
    constructor(scene) {
        this.scene = scene;
        this.createDecorations();
    }

    createDecorations() {
        // Create decorative group
        this.decorativeGroup = new THREE.Group();
        
        // Add benches along the pier
        this.addBenches();
        
        // Add trash bins
        this.addTrashBins();
        
        // Add lamp posts
        this.addLampPosts();
        
        // Add the scene
        this.scene.add(this.decorativeGroup);
    }

    addBenches() {
        const benchMaterial = createStandardMaterial(0x8B4513, 0.7, 0.2);
        
        // Create bench geometry
        const benchGeometry = createBoxGeometry(2, 0.4, 0.5);
        const benchBackGeometry = createBoxGeometry(2, 0.8, 0.1);
        
        // Add benches along the pier
        const benchPositions = [
            [-15, 0.2, 8], [-5, 0.2, 8], [5, 0.2, 8], [15, 0.2, 8],
            [-15, 0.2, -8], [-5, 0.2, -8], [5, 0.2, -8], [15, 0.2, -8]
        ];
        
        benchPositions.forEach(pos => {
            const bench = new THREE.Group();
            
            // Bench seat
            const seat = new THREE.Mesh(benchGeometry, benchMaterial);
            seat.position.set(0, 0.2, 0);
            bench.add(seat);
            
            // Bench back
            const back = new THREE.Mesh(benchBackGeometry, benchMaterial);
            back.position.set(0, 0.6, -0.2);
            bench.add(back);
            
            // Bench legs
            const legGeometry = createBoxGeometry(0.1, 0.4, 0.1);
            const legMaterial = createStandardMaterial(0x6B3E14, 0.8);
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.9, 0, 0);
            bench.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.9, 0, 0);
            bench.add(rightLeg);
            
            bench.position.set(pos[0], pos[1], pos[2]);
            bench.userData.isCollidable = true;
            this.decorativeGroup.add(bench);
        });
    }

    addTrashBins() {
        const binMaterial = createStandardMaterial(0x333333, 0.8);
        const binGeometry = createBoxGeometry(0.4, 0.8, 0.4);
        
        const binPositions = [
            [-18, 0.4, 8], [-8, 0.4, 8], [8, 0.4, 8], [18, 0.4, 8],
            [-18, 0.4, -8], [-8, 0.4, -8], [8, 0.4, -8], [18, 0.4, -8]
        ];
        
        binPositions.forEach(pos => {
            const bin = new THREE.Mesh(binGeometry, binMaterial);
            bin.position.set(pos[0], pos[1], pos[2]);
            this.decorativeGroup.add(bin);
        });
    }

    addLampPosts() {
        const lampMaterial = createStandardMaterial(0xCCCCCC, 0.8);
        const lampLightMaterial = createStandardMaterial(0xFFFF00, 0.5, 0.8, 0xFFFF00, 0.5);
        
        const lampPositions = [
            [-15, 0, 9], [-5, 0, 9], [5, 0, 9], [15, 0, 9],
            [-15, 0, -9], [-5, 0, -9], [5, 0, -9], [15, 0, -9]
        ];
        
        lampPositions.forEach(pos => {
            const lamp = new THREE.Group();
            
            // Lamp post
            const post = new THREE.Mesh(createBoxGeometry(0.1, 2, 0.1), lampMaterial);
            post.position.set(0, 1, 0);
            lamp.add(post);
            
            // Lamp head
            const head = new THREE.Mesh(createBoxGeometry(0.4, 0.1, 0.4), lampMaterial);
            head.position.set(0, 2, 0);
            lamp.add(head);
            
            // Lamp light
            const light = new THREE.Mesh(createBoxGeometry(0.3, 0.1, 0.3), lampLightMaterial);
            light.position.set(0, 2.05, 0);
            lamp.add(light);
            
            lamp.position.set(pos[0], pos[1], pos[2]);
            this.decorativeGroup.add(lamp);
        });
    }

    addPalmTree(x, y, z) {
        const palmGroup = new THREE.Group();
        
        // Trunk
        const trunkGeometry = createCylinderGeometry(0.1, 0.15, 2, 8);
        const trunkMaterial = createStandardMaterial(0x8B4513, 0.8);
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 1;
        palmGroup.add(trunk);
        
        // Leaves
        const leafMaterial = createStandardMaterial(0x00AA00, 0.7, 0.2, 0x003300, 0.2);
        
        for (let i = 0; i < 5; i++) {
            const leafGeometry = createBoxGeometry(0.8, 0.05, 0.3);
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.y = 2;
            leaf.rotation.y = (i / 5) * Math.PI * 2;
            leaf.rotation.x = -0.2;
            leaf.position.x = Math.sin(leaf.rotation.y) * 0.5;
            leaf.position.z = Math.cos(leaf.rotation.y) * 0.5;
            palmGroup.add(leaf);
        }
        
        palmGroup.position.set(x, y, z);
        this.scene.add(palmGroup);
    }

    addBeachChair(x, y, z) {
        const chairGroup = new THREE.Group();
        
        // Chair base
        const baseGeometry = createBoxGeometry(0.8, 0.1, 1.5);
        const chairMaterial = createStandardMaterial(0xFFD700, 0.5, 0.2, 0x332200, 0.1);
        const base = new THREE.Mesh(baseGeometry, chairMaterial);
        base.position.y = 0.05;
        chairGroup.add(base);
        
        // Chair back
        const backGeometry = createBoxGeometry(0.8, 0.8, 0.1);
        const back = new THREE.Mesh(backGeometry, chairMaterial);
        back.position.set(0, 0.4, -0.7);
        back.rotation.x = Math.PI / 6;
        chairGroup.add(back);
        
        chairGroup.position.set(x, y, z);
        this.scene.add(chairGroup);
    }

    addKiosk(x, y, z) {
        const kioskGroup = new THREE.Group();
        
        // Kiosk base
        const baseGeometry = createBoxGeometry(2, 1.5, 1.5);
        const baseMaterial = createStandardMaterial(0x1E90FF, 0.5, 0.2, 0x001133, 0.2);
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.75;
        kioskGroup.add(base);
        
        // Kiosk roof
        const roofGeometry = createBoxGeometry(2.4, 0.1, 1.9);
        const roofMaterial = createStandardMaterial(0xFF6347, 0.7, 0.2, 0x330000, 0.1);
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.y = 1.55;
        kioskGroup.add(roof);
        
        // Counter
        const counterGeometry = createBoxGeometry(2, 0.1, 0.5);
        const counterMaterial = createStandardMaterial(0xDEB887, 0.6);
        const counter = new THREE.Mesh(counterGeometry, counterMaterial);
        counter.position.set(0, 1, 0.8);
        kioskGroup.add(counter);
        
        kioskGroup.position.set(x, y, z);
        this.scene.add(kioskGroup);
    }

    addBoat(x, y, z) {
        const boatGroup = new THREE.Group();
        
        // Boat hull
        const hullGeometry = createBoxGeometry(2, 0.5, 1);
        const hullMaterial = createStandardMaterial(0x964B00, 0.7);
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);
        hull.position.y = 0.25;
        boatGroup.add(hull);
        
        // Boat interior
        const interiorGeometry = createBoxGeometry(1.8, 0.2, 0.8);
        const interiorMaterial = createStandardMaterial(0xDEB887, 0.6);
        const interior = new THREE.Mesh(interiorGeometry, interiorMaterial);
        interior.position.y = 0.4;
        boatGroup.add(interior);
        
        boatGroup.position.set(x, y, z);
        this.scene.add(boatGroup);
    }

    addFishingSpot(x, y, z) {
        const fishingGroup = new THREE.Group();
        
        // Fishing rod
        const rodGeometry = createCylinderGeometry(0.02, 0.02, 1.5, 8);
        const rodMaterial = createStandardMaterial(0x8B4513, 0.8);
        const rod = new THREE.Mesh(rodGeometry, rodMaterial);
        rod.position.y = 0.75;
        rod.rotation.x = -Math.PI / 4;
        rod.rotation.z = Math.PI / 10;
        fishingGroup.add(rod);
        
        // Fishing line
        const lineGeometry = new THREE.BufferGeometry();
        const linePoints = [
            new THREE.Vector3(0, 1.5, -0.75),
            new THREE.Vector3(0.2, 0.5, -1.5),
            new THREE.Vector3(0.2, 0, -1.5)
        ];
        lineGeometry.setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        fishingGroup.add(line);
        
        fishingGroup.position.set(x, y, z);
        this.scene.add(fishingGroup);
    }

    addBeachBall(x, y, z) {
        const ballGeometry = createSphereGeometry(0.3, 16, 16);
        const ballMaterial = createStandardMaterial(0xFF6347, 0.4, 0.2, 0x330000, 0.1);
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(x, y + 0.3, z);
        this.scene.add(ball);
        
        // Store for animation
        this.beachBall = ball;
    }

    addNeonSign(x, y, z, text, color) {
        const signGroup = new THREE.Group();
        
        // Sign background
        const backGeometry = createBoxGeometry(text.length * 0.5, 0.8, 0.1);
        const backMaterial = createStandardMaterial(0x111111, 0.9, 0.2);
        const back = new THREE.Mesh(backGeometry, backMaterial);
        signGroup.add(back);
        
        // Create neon text effect with small cubes
        const textGroup = new THREE.Group();
        const cubeSize = 0.1;
        const letterSpacing = 0.25;
        const startX = -(text.length - 1) * letterSpacing / 2;
        
        // Simple pixel font patterns for each letter
        const patterns = {
            'P': [
                [1,1,1],
                [1,0,1],
                [1,1,1],
                [1,0,0],
                [1,0,0]
            ],
            'I': [
                [1,1,1],
                [0,1,0],
                [0,1,0],
                [0,1,0],
                [1,1,1]
            ],
            'E': [
                [1,1,1],
                [1,0,0],
                [1,1,1],
                [1,0,0],
                [1,1,1]
            ],
            'R': [
                [1,1,1],
                [1,0,1],
                [1,1,1],
                [1,0,1],
                [1,0,1]
            ],
            'B': [
                [1,1,0],
                [1,0,1],
                [1,1,0],
                [1,0,1],
                [1,1,0]
            ],
            'O': [
                [1,1,1],
                [1,0,1],
                [1,0,1],
                [1,0,1],
                [1,1,1]
            ],
            'Y': [
                [1,0,1],
                [1,0,1],
                [0,1,0],
                [0,1,0],
                [0,1,0]
            ]
        };
        
        const cubeMaterial = createStandardMaterial(color, 0.3, 0.8, color, 1);
        
        for (let i = 0; i < text.length; i++) {
            const letter = text[i];
            const pattern = patterns[letter];
            
            if (pattern) {
                for (let row = 0; row < pattern.length; row++) {
                    for (let col = 0; col < pattern[row].length; col++) {
                        if (pattern[row][col]) {
                            const cube = new THREE.Mesh(
                                createBoxGeometry(cubeSize, cubeSize, cubeSize),
                                cubeMaterial
                            );
                            cube.position.set(
                                startX + i * letterSpacing + (col - 1) * cubeSize,
                                0.2 - row * cubeSize,
                                0.1
                            );
                            textGroup.add(cube);
                        }
                    }
                }
            }
        }
        
        signGroup.add(textGroup);
        signGroup.position.set(x, y, z);
        signGroup.rotation.y = Math.PI;
        this.scene.add(signGroup);
    }

    update(deltaTime) {
        // Animate beach ball
        if (this.beachBall) {
            const time = Date.now() * 0.001;
            this.beachBall.position.y = 0.3 + Math.sin(time * 2) * 0.05;
            this.beachBall.rotation.y += deltaTime;
        }
    }
} 

```

```
// js/main.js
import * as THREE from 'three';
import { Character } from './character.js';
import { Pier } from './pier.js';
import { DecorativeElements } from './decorative.js';
import { NPC } from './npc.js';
import { Billboard } from './billboard.js';
import { ChatSystem } from './chat.js';
import { Portal } from './portal.js';
import { createWaitingRoomScene } from './waitingRoom.js';
import { TitleScreen } from './titleScreen.js';

// Scene names and spawn points
const MAIN_AREA_NAME = 'mainArea';
const WAITING_ROOM_NAME = 'waitingRoom';
const mainAreaSpawnPoint = new THREE.Vector3(0, 3., -4)
const waitingRoomSpawnPoint = new THREE.Vector3(0, 1.0, 0);

// Game states
const GAME_STATE = {
    TITLE: 'title',
    PLAYING: 'playing'
};

export class EBOYIsometricPierScene {
    constructor() {
        console.log("Starting IsometricPierScene initialization...");
        
        try {
            // Initialize game state
            this.gameState = GAME_STATE.TITLE;
            
            // Get container
            const container = document.getElementById('scene-container');
            if (!container) {
                throw new Error('Scene container not found!');
            }

            // Create title screen first
            console.log("Creating title screen...");
            this.titleScreen = new TitleScreen(container);
            
            // Add event listeners for menu interaction
            this.setupMenuInteraction();
            
            // Initialize main game components (but don't show them yet)
            this.initializeMainGame();
            
            console.log("Isometric Pier Scene successfully initialized!");
        } catch (error) {
            console.error("Error during initialization:", error);
            throw error;
        }
    }

    setupMenuInteraction() {
        window.addEventListener('keydown', (e) => {
            if (this.gameState === GAME_STATE.TITLE) {
                if (e.code === 'Enter') {
                    this.startGame();
                }
            }
        });

        // Listen for startGame event from title screen
        window.addEventListener('startGame', () => {
            if (this.gameState === GAME_STATE.TITLE) {
                this.startGame();
            }
        });
    }

    initializeMainGame() {
        // Scene setup
        this.mainScene = new THREE.Scene();
        this.mainScene.background = new THREE.Color(0x000033);
        
        // Add San Francisco fog with increased density
        this.mainScene.fog = new THREE.Fog(0x000033, 10, 50);
        
        // Create waiting room scene
        this.waitingRoomScene = createWaitingRoomScene(MAIN_AREA_NAME, mainAreaSpawnPoint);
        
        // Set current scene to main scene initially
        this.currentScene = this.mainScene;
        this.activePortals = this.mainScene.userData.portals || [];
        
        // Create portal to waiting room in main scene
        const portalToWaitingRoomPos = new THREE.Vector3(5, 2.5, -3);
        const portalToWaitingRoom = new Portal(
            this.mainScene,
            portalToWaitingRoomPos,
            1.5,
            WAITING_ROOM_NAME,
            waitingRoomSpawnPoint
        );
        this.mainScene.userData.portals = [portalToWaitingRoom];
        this.activePortals = this.mainScene.userData.portals;
        
        // Create Matrix rain
        this.createMatrixRain();
        
        // Camera setup for isometric view
        const aspect = window.innerWidth / window.innerHeight;
        this.camera = new THREE.OrthographicCamera(
            -10 * aspect, 10 * aspect, 10, -10, 0.1, 1000
        );
        
        // Set camera position for isometric view
        this.camera.position.set(15, 15, 15);
        this.camera.lookAt(0, 0, 0);
        
        // Renderer setup
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        
        // Basic lighting
        this.setupLighting();

        // Create scene elements
        this.pier = new Pier(this.mainScene);

        // Create player character
        this.character = new Character(this.mainScene, null, 'Player');
        this.character.characterGroup.position.copy(mainAreaSpawnPoint);
        this.character.characterState.x = mainAreaSpawnPoint.x;
        this.character.characterState.y = mainAreaSpawnPoint.y;
        this.character.characterState.z = mainAreaSpawnPoint.z;
        this.character.characterState.baseY = mainAreaSpawnPoint.y;
        
        // Initialize chat system
        this.chatSystem = new ChatSystem(this.character);
        this.character.chatSystem = this.chatSystem;

        // Create decorative elements
        this.decorativeElements = new DecorativeElements(this.mainScene);

        // Create billboard
        this.billboard = new Billboard(this.mainScene);

        // Create NPCs
        this.npcs = [];
        for (let i = 0; i < 10; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 38,
                0.9,
                (Math.random() - 0.5) * 18
            );
            this.npcs.push(new NPC(this.mainScene, position, this.chatSystem, `NPC-${i + 1}`));
        }
        
        // Input handling
        this.keys = {};
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        window.addEventListener('keyup', (e) => this.onKeyUp(e));
        
        // Handle window resize
        window.addEventListener('resize', () => this.onWindowResize());
        
        // Clock for frame-rate independent movement
        this.clock = new THREE.Clock();
        
        // Array to hold bounding box visual helpers
        this.boundingBoxHelpers = [];
    }

    startGame() {
        // Remove title screen
        if (this.titleScreen) {
            this.titleScreen.renderer.domElement.remove();
            this.titleScreen = null;
        }

        // Add main game renderer to container
        const container = document.getElementById('scene-container');
        container.appendChild(this.renderer.domElement);

        // Show chat container
        const chatContainer = document.getElementById('chat-container');
        if (chatContainer) {
            chatContainer.style.display = 'block';
        }

        // Change game state
        this.gameState = GAME_STATE.PLAYING;

        // Add welcome message
        this.chatSystem.addSystemMessage("Welcome to the Cyberpunk Pier! Use Arrows to move, E to throw discs.");

        // Start animation loop
        this.animate();
    }

    setupLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x333333, 0.5);
        this.mainScene.add(ambientLight);
        
        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 15);
        this.mainScene.add(directionalLight);
        
        // Add colored point lights for EBOY style neon effect
        const pinkLight = new THREE.PointLight(0xff00ff, 1, 10);
        pinkLight.position.set(5, 3, 5);
        this.mainScene.add(pinkLight);
        
        const cyanLight = new THREE.PointLight(0x00ffff, 1, 10);
        cyanLight.position.set(-5, 3, -5);
        this.mainScene.add(cyanLight);
        
        const greenLight = new THREE.PointLight(0x00ff00, 0.8, 8);
        greenLight.position.set(0, 2, -3);
        this.mainScene.add(greenLight);
        
        // Store lights for animation
        this.neonLights = [pinkLight, cyanLight, greenLight];
    }
    
    onKeyDown(event) {
        this.keys[event.code] = true;
        
        // Prevent default behavior for arrow keys and space
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyE'].includes(event.code)) {
            event.preventDefault();
        }
    }
    
    onKeyUp(event) {
        this.keys[event.code] = false;
    }
    
    onWindowResize() {
        const aspect = window.innerWidth / window.innerHeight;
        this.camera.left = -10 * aspect;
        this.camera.right = 10 * aspect;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    updateCamera() {
        // Camera following with isometric offset
        const cameraOffset = new THREE.Vector3(15, 15, 15);
        const characterPos = this.character.getPosition();
        const targetCameraPosition = new THREE.Vector3(
            characterPos.x + cameraOffset.x,
            cameraOffset.y,
            characterPos.z + cameraOffset.z
        );
        
        // Smoothly interpolate camera position
        this.camera.position.lerp(targetCameraPosition, 0.05);
        
        // Look at character
        this.camera.lookAt(
            characterPos.x,
            characterPos.y,
            characterPos.z
        );
    }
    
    createMatrixRain() {
        // Create particle system
        const particleCount = 5000;
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        
        // Initialize particles
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Random position in a wide area - keep away from camera view at top
            positions[i3] = (Math.random() - 0.5) * 100;     // x
            positions[i3 + 1] = Math.random() * 30 + 30;    // y (start higher above scene to avoid UI)
            positions[i3 + 2] = (Math.random() - 0.5) * 100; // z
            
            // Random velocity (mostly downward with slight random movement)
            velocities[i3] = (Math.random() - 0.5) * 0.5;    // x
            velocities[i3 + 1] = -Math.random() * 2 - 1;    // y (falling)
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.5; // z
        }
        
        // Create geometry and attributes
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // Create material with Matrix-style green color
        const material = new THREE.PointsMaterial({
            color: 0x00ff00,
            size: 0.5,
            transparent: true,
            opacity: 0.6,
            sizeAttenuation: true
        });
        
        // Create particle system
        this.rain = new THREE.Points(geometry, material);
        
        // Add rain to both scenes - ensure this doesn't create DOM elements
        this.mainScene.add(this.rain);
        // Clone the rain rather than create a new instance to ensure we don't get extra DOM elements
        // const rainClone = this.rain.clone();
        // this.waitingRoomScene.add(rainClone);
        
        // Store velocities for animation
        this.rainVelocities = velocities;
    }

    updateRain(deltaTime) {
        if (!this.rain || !this.rainVelocities) return;
        
        const positions = this.rain.geometry.attributes.position.array;
        
        for (let i = 0; i < positions.length; i += 3) {
            // Update position based on velocity
            positions[i] += this.rainVelocities[i] * deltaTime;
            positions[i + 1] += this.rainVelocities[i + 1] * deltaTime;
            positions[i + 2] += this.rainVelocities[i + 2] * deltaTime;
            
            // Reset particle if it falls below ground
            if (positions[i + 1] < -10) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = Math.random() * 50 + 20;
                positions[i + 2] = (Math.random() - 0.5) * 100;
                
                // Reset velocity
                this.rainVelocities[i] = (Math.random() - 0.5) * 0.5;
                this.rainVelocities[i + 1] = -Math.random() * 2 - 1;
                this.rainVelocities[i + 2] = (Math.random() - 0.5) * 0.5;
            }
        }
        
        this.rain.geometry.attributes.position.needsUpdate = true;
    }

    switchScene(targetSceneName, targetSpawnPoint) {
        console.log(`Switching to ${targetSceneName} at ${targetSpawnPoint.x}, ${targetSpawnPoint.y}, ${targetSpawnPoint.z}`);

        // Remove character from the old scene
        this.currentScene.remove(this.character.characterGroup);

        // Find the target scene object
        let targetScene;
        if (targetSceneName === MAIN_AREA_NAME) {
            targetScene = this.mainScene;
        } else if (targetSceneName === WAITING_ROOM_NAME) {
            targetScene = this.waitingRoomScene;
        } else {
            console.error("Unknown target scene:", targetSceneName);
            return;
        }

        // Set the new current scene and its portals
        this.currentScene = targetScene;
        this.activePortals = this.currentScene.userData.portals || [];

        // Add character to the new scene
        this.currentScene.add(this.character.characterGroup);

        // Move character to the spawn point in the new scene
        this.character.characterGroup.position.copy(targetSpawnPoint);
        // Reset character's internal state coordinates
        this.character.characterState.x = targetSpawnPoint.x;
        this.character.characterState.y = targetSpawnPoint.y;
        this.character.characterState.z = targetSpawnPoint.z;
        this.character.characterState.baseY = targetSpawnPoint.y;
        this.character.characterState.velocity.set(0, 0, 0);
        this.character.characterState.isJumping = false;
        this.character.characterState.jumpVelocity = 0;

        // Update character's scene reference
        this.character.scene = this.currentScene;
        // Update character's chat system reference (though it's the same instance)
        this.character.chatSystem = this.chatSystem;
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        
        const deltaTime = this.clock.getDelta();

        // --- Clear previous BBox Helpers ---
        this.boundingBoxHelpers.forEach(helper => this.currentScene.remove(helper));
        this.boundingBoxHelpers = [];

        // --- Prepare Obstacles for Collision ---
        const obstacles = [];
        const tempBox = new THREE.Box3(); // Reuse Box3 object for efficiency

        // Function to add an object's AABB if it's marked as collidable
        const addCollidableObstacle = (object) => {
            // Check if the object itself is marked
            if (object.userData.isCollidable) {
                tempBox.setFromObject(object, true); // Use precise bounding box
                // --- DEBUG: Log AABB for benches ---
                // Heuristic: Assume benches are Groups marked as collidable
                if (object.isGroup) { 
                    console.log(`Calculated AABB for collidable Group (${object.name || ''}): `,
                                `Min: ${tempBox.min.x.toFixed(2)}, ${tempBox.min.y.toFixed(2)}, ${tempBox.min.z.toFixed(2)}`, 
                                `Max: ${tempBox.max.x.toFixed(2)}, ${tempBox.max.y.toFixed(2)}, ${tempBox.max.z.toFixed(2)}`);
                }
                // --- END DEBUG ---
                // Ensure the box is valid (has volume)
                if (!tempBox.isEmpty()) {
                     const obstacleData = { aabb: tempBox.clone(), object: object };
                     obstacles.push(obstacleData);
                     // Add BBox helper
                     const helper = new THREE.Box3Helper(obstacleData.aabb, 0xffff00); // Yellow
                     this.currentScene.add(helper);
                     this.boundingBoxHelpers.push(helper);
                }
            }
            // Traverse children only if the object is *not* collidable itself
            // (avoids adding parts of an already added object)
            else if (object.children && object.children.length > 0) {
                 object.traverse((child) => {
                     if (child !== object && child.userData.isCollidable) {
                         // --- Log found collidable child ---
                         console.log(`Found collidable child: Name='${child.name || 'N/A'}', Type='${child.type}', isGroup=${child.isGroup}`);
                         // --- END Log ---
                         
                         const childBox = new THREE.Box3();
                         
                         if (child.isGroup) {
                             // Manually compute AABB for Groups by encompassing children
                             childBox.makeEmpty(); // Start with an empty box
                             child.traverse((subChild) => {
                                 if (subChild.isMesh) {
                                     const subChildBox = new THREE.Box3().setFromObject(subChild, true);
                                     if (!subChildBox.isEmpty()) {
                                         childBox.expandByPoint(subChildBox.min);
                                         childBox.expandByPoint(subChildBox.max);
                                     }
                                 }
                             });
                              // Log the manually calculated AABB for the group
                              console.log(`Manually Calculated AABB for collidable Child Group (${child.name || 'Group'}): `,
                                 `Min: ${childBox.min.x.toFixed(2)}, ${childBox.min.y.toFixed(2)}, ${childBox.min.z.toFixed(2)}`, 
                                 `Max: ${childBox.max.x.toFixed(2)}, ${childBox.max.y.toFixed(2)}, ${childBox.max.z.toFixed(2)}`);

                         } else {
                             // For non-groups (like individual railing meshes), use setFromObject directly
                             childBox.setFromObject(child, true);
                         }
                         // --- End Modified Handling ---

                         if (!childBox.isEmpty()) {
                             const obstacleData = { aabb: childBox.clone(), object: child };
                             obstacles.push(obstacleData);
                             // Add BBox helper
                             const helper = new THREE.Box3Helper(obstacleData.aabb, 0xffff00); // Yellow
                             this.currentScene.add(helper);
                             this.boundingBoxHelpers.push(helper);
                         }
                     }
                 });
            }
        };


        // Add collidable elements from the main scene objects
        if (this.pier && this.pier.pierGroup) {
            addCollidableObstacle(this.pier.pierGroup);
        }
        if (this.decorativeElements && this.decorativeElements.decorativeGroup) {
            addCollidableObstacle(this.decorativeElements.decorativeGroup);
        }
        if (this.billboard && this.billboard.billboardGroup) {
             addCollidableObstacle(this.billboard.billboardGroup);
        } else if (this.billboard && this.billboard.mesh && this.billboard.mesh.userData.isCollidable) {
             // Fallback for single mesh billboard if marked
             tempBox.setFromObject(this.billboard.mesh, true);
             if (!tempBox.isEmpty()) {
                 const obstacleData = { aabb: tempBox.clone(), object: this.billboard.mesh };
                 obstacles.push(obstacleData);
                  // Add BBox helper
                 const helper = new THREE.Box3Helper(obstacleData.aabb, 0xffff00); // Yellow
                 this.currentScene.add(helper);
                 this.boundingBoxHelpers.push(helper);
             }
        }

        // Add NPCs as obstacles (assuming the main group is collidable)
        this.npcs.forEach(npc => {
            if (npc.npcGroup) { // Assuming npc has an npcGroup
                 // Consider if NPCs should *always* be obstacles or if they need marking too
                 // For now, let's assume they are always obstacles
                 tempBox.setFromObject(npc.npcGroup, true);
                 if (!tempBox.isEmpty()) {
                     const obstacleData = { aabb: tempBox.clone(), object: npc.npcGroup };
                     obstacles.push(obstacleData);
                      // Add BBox helper
                     const helper = new THREE.Box3Helper(obstacleData.aabb, 0xffff00); // Yellow
                     this.currentScene.add(helper);
                     this.boundingBoxHelpers.push(helper);
                 }
            }
        });

        // Add active portals - These are generally NOT obstacles
        // this.activePortals.forEach(portal => { ... });

        // --- DEBUG: Log collected obstacles ---
        if (deltaTime > 0) { // Log only once per frame effectively, avoid flooding
            // console.log(`Frame obstacles: ${obstacles.length}`);
            // Optionally log names/types of first few obstacles
            // if (obstacles.length > 0) {
            //     console.log(`First obstacles:`, obstacles.slice(0, 5).map(o => o.object.name || o.object.type));
            // }
        }
        // --- END DEBUG ---


        // --- Update Game Elements ---

        // Update character (pass newly filtered obstacles)
        this.character.update(deltaTime, this.keys, this.camera, obstacles, this.activePortals);

        // Update NPCs
        this.npcs.forEach(npc => {
            npc.update(deltaTime, this.camera);
        });
        
        // Update decorative elements
        this.decorativeElements.update(deltaTime);
        
        // Update billboard
        this.billboard.update(deltaTime);
        
        // Update portals
        this.activePortals.forEach(portal => {
            portal.update(deltaTime);
            if (portal.checkForActivation(this.character.getPosition())) {
                const target = portal.getTarget();
                this.switchScene(target.sceneName, target.spawnPoint);
            }
        });
        
        // Update camera
        this.updateCamera();
        
        // Update rain
        this.updateRain(deltaTime);
        
        // Render current scene
        this.renderer.render(this.currentScene, this.camera);
    }
} 

```

```
import { Character } from './character.js';
import * as THREE from 'three';

export class NPC extends Character {
    constructor(scene, position, chatSystem, name) {
        console.log(`Creating NPC ${name} at position:`, position);
        super(scene, chatSystem, name);
        
        this.chatSystem = chatSystem;
        
        this.characterGroup.position.copy(position);
        
        // Define cyberpunk color combinations for clothes
        const cyberpunkColors = [
            // Neon Pink & Electric Blue
            { hoodie: 0xff00ff, pants: 0x00ffff },
            // Toxic Green & Purple
            { hoodie: 0x00ff00, pants: 0x800080 },
            // Hot Orange & Cyan
            { hoodie: 0xff6600, pants: 0x00ffff },
            // Electric Yellow & Magenta
            { hoodie: 0xffff00, pants: 0xff00ff },
            // Neon Blue & Hot Pink
            { hoodie: 0x00ffff, pants: 0xff00ff },
            // Purple & Lime
            { hoodie: 0x800080, pants: 0x00ff00 },
            // Red & Cyan
            { hoodie: 0xff0000, pants: 0x00ffff },
            // Yellow & Purple
            { hoodie: 0xffff00, pants: 0x800080 }
        ];
        
        // Define specific hair colors
        const hairColors = [
            0xFFD700, // Blonde
            0x000000, // Black
            0x0000FF, // Blue
            0xFF00FF, // Pink
            0x800080  // Purple
        ];
        
        // Randomly select a color combination and hair color
        const colors = cyberpunkColors[Math.floor(Math.random() * cyberpunkColors.length)];
        const hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];
        
        // Apply colors to the character's materials
        this.applyColors(colors, hairColor);
        
        // Setup speech bubble properties
        this.speechTimer = 0;
        this.speechInterval = 10 + Math.random() * 15; // Random interval between 10-25 seconds
        this.lastMessage = '';
        
        // Define random messages
        this.messages = [
            "The rain feels electric tonight.",
            "Did you see that glitch in the sky?",
            "This pier has seen things...",
            "Need more neon.",
            "Keep the vibes flowing.",
            "Watch out for the data streams.",
            "My circuits are buzzing.",
            "The future is bright... and rainy.",
            "Synthwave and solitude.",
            "Just thinking about the digital sea.",
            "Is this real life?",
            "Lost in the code.",
            "These colors... wow.",
            "Can't stop the signal.",
            "Waiting for the next drop."
        ];
        
        this.setupIdleBehavior();
        console.log(`NPC ${name} created successfully.`);
    }

    applyColors(colors, hairColor) {
        // Update hoodie color
        this.characterGroup.children.forEach(child => {
            if (child.name === 'hoodie' || child.name === 'hood' || 
                child.name === 'leftArm' || child.name === 'rightArm') {
                child.material.color.setHex(colors.hoodie);
            }
            // Update pants color (legs)
            if (child.name === 'leftLeg' || child.name === 'rightLeg') {
                child.material.color.setHex(colors.pants);
            }
            // Update hair color
            if (child.name === 'hair' || child instanceof THREE.Mesh && 
                child.material.color.getHex() === 0x3a1f13) {
                child.material.color.setHex(hairColor);
            }
        });
    }

    setupIdleBehavior() {
        this.idleState = {
            targetPosition: new THREE.Vector3(),
            moveSpeed: 2,
            idleTimer: 0,
            idleDuration: 3 + Math.random() * 4, // Random duration between 3-7 seconds
            isMoving: false,
            waitTime: 0,
            maxWaitTime: 2 + Math.random() * 3, // Random wait time between 2-5 seconds
            // Add idle animation states
            idleAnimationTime: Math.random() * Math.PI * 2, // Random start phase
            idleAnimationSpeed: 0.5 + Math.random() * 0.5, // Random animation speed
            shouldWaveArm: Math.random() < 0.3 // 30% chance to wave while idle
        };
        this.updateTargetPosition();
    }

    updateTargetPosition() {
        // Random position within pier boundaries
        this.idleState.targetPosition.set(
            (Math.random() - 0.5) * 38, // -19 to 19
            0.9, // Keep on pier surface
            (Math.random() - 0.5) * 18  // -9 to 9
        );
        this.idleState.isMoving = true;
        this.idleState.waitTime = 0;
        // Reset idle animation state
        this.idleState.shouldWaveArm = Math.random() < 0.3;
    }

    update(deltaTime, camera) {
        if (!this.characterGroup) {
            console.error(`NPC ${this.name} characterGroup is undefined`);
            return;
        }
        if (!this.chatSystem) {
             console.error(`NPC ${this.name} chatSystem is undefined`);
             // Don't proceed with chat logic if system is missing
        } else {
             // Update speech timing
             this.speechTimer += deltaTime;
             if (this.speechTimer >= this.speechInterval) {
                 this.speechTimer = 0;
                 this.speechInterval = 10 + Math.random() * 15; // New random interval

                 // Select a new random message different from the last one
                 let newMessage;
                 do {
                     newMessage = this.messages[Math.floor(Math.random() * this.messages.length)];
                 } while (newMessage === this.lastMessage && this.messages.length > 1);

                 this.lastMessage = newMessage;
                 // MODIFIED: Use the character's say method for speech bubble
                 this.say(newMessage); 
                 // ALSO add to chat log
                 this.chatSystem.addNPCMessage(this.name, newMessage);
             }
        }

        // Update speech bubble if active (Let Character class handle this)
        // if (this.activeSpeechBubble) { 
        //     this.activeSpeechBubble.update(this.characterGroup.position, camera);
        // }
        // We call the parent update method AFTER our NPC-specific logic
        // This ensures the base Character update (movement, animations, speech bubble update) runs.
        super.update(deltaTime, {}, camera, [], []); // Pass empty keys, obstacles, portals for base update

        // --- NPC Idle Movement Logic (moved from Character.update) ---
        // Update idle behavior timer (previously part of Character update, now specific to NPC)
        // this.idleState.idleTimer += deltaTime; // Timer update handled by base Character class now if needed

        if (this.idleState.isMoving) {
            // Calculate direction to target
            const direction = this.idleState.targetPosition.clone()
                .sub(this.characterGroup.position);
            const distance = direction.length();

            if (distance > 0.1) {
                // Normalize and apply movement
                direction.normalize();
                this.characterGroup.position.x += direction.x * this.idleState.moveSpeed * deltaTime;
                this.characterGroup.position.z += direction.z * this.idleState.moveSpeed * deltaTime;

                // Update rotation to face movement direction
                this.characterGroup.rotation.y = Math.atan2(direction.x, direction.z);

                // Update walk animation state (handled by base Character class)
                this.characterState.isWalking = true; 

            } else {
                // Reached target position, start waiting
                this.idleState.isMoving = false;
                this.idleState.waitTime = 0;
                this.characterState.isWalking = false; // Stop walking animation state
                // Update target position after waiting
                // We'll handle this in the waiting section below
            }
        } else {
            // Update waiting time
            this.idleState.waitTime += deltaTime;
            this.characterState.isWalking = false; // Ensure not walking while waiting

            // Perform idle animations (handled by base Character class)
            this.characterState.isIdle = true;
            this.characterState.shouldWaveArm = this.idleState.shouldWaveArm; // Pass waving state

            // If wait time exceeded, find a new target
            if (this.idleState.waitTime >= this.idleState.maxWaitTime) {
                this.updateTargetPosition();
                this.characterState.isIdle = false; // Start moving again
            }
        }
        // --- End NPC Idle Movement Logic ---
    }
} 
```

```
// js/particleSystem.js
// ParticleSystem.js
import * as THREE from 'three';

export class ParticleSystem {
    constructor(parent, options = {}) {
        this.parent = parent; // The object particles should be relative to (or the scene)
        this.options = {
            particleCount: options.particleCount || 500,
            color: options.color || new THREE.Color(0xffffff),
            secondaryColor: options.secondaryColor, // Optional second color
            size: options.size || 0.1,
            spawnRadius: options.spawnRadius || 1,
            lifetime: options.lifetime || 2,
            velocity: options.velocity || new THREE.Vector3(0, 1, 0), // Base velocity
            velocitySpread: options.velocitySpread || new THREE.Vector3(0.5, 0.5, 0.5),
            gravity: options.gravity || -0.5, // Simple downward pull
            blending: options.blending || THREE.NormalBlending,
            texture: options.texture, // Optional THREE.Texture
            opacity: options.opacity || 1.0
        };

        this.particles = [];
        this.geometry = new THREE.BufferGeometry();
        this.material = new THREE.PointsMaterial({
            size: this.options.size,
            vertexColors: true, // Use colors defined per particle
            transparent: true,
            opacity: this.options.opacity,
            blending: this.options.blending,
            sizeAttenuation: true, // Particles smaller further away
            map: this.options.texture,
            depthWrite: false // Often looks better for additive blending
        });

        this.points = new THREE.Points(this.geometry, this.material);
        this.parent.add(this.points);

        this.positions = new Float32Array(this.options.particleCount * 3);
        this.colors = new Float32Array(this.options.particleCount * 3);
        this.velocities = [];
        this.ages = new Float32Array(this.options.particleCount);
        this.lifetimes = new Float32Array(this.options.particleCount);

        // Initialize particles off-screen or inactive
        for (let i = 0; i < this.options.particleCount; i++) {
            this.ages[i] = this.options.lifetime; // Start as "dead"
            this.positions[i * 3 + 1] = -9999; // Position off-screen
        }
        this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
        this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
    }

    spawnParticle(index) {
        const i3 = index * 3;

        // Initial Position (randomly on a sphere surface within spawnRadius)
        const pos = new THREE.Vector3(
            (Math.random() - 0.5),
            (Math.random() - 0.5),
            (Math.random() - 0.5)
        ).normalize().multiplyScalar(this.options.spawnRadius * (0.8 + Math.random() * 0.4)); // Spawn in a shell

        this.positions[i3 + 0] = pos.x;
        this.positions[i3 + 1] = pos.y;
        this.positions[i3 + 2] = pos.z;

        // Color
        const color = this.options.secondaryColor && Math.random() > 0.5 ? this.options.secondaryColor : this.options.color;
        this.colors[i3 + 0] = color.r;
        this.colors[i3 + 1] = color.g;
        this.colors[i3 + 2] = color.b;

        // Velocity (base + random spread)
        this.velocities[index] = new THREE.Vector3(
            this.options.velocity.x + (Math.random() - 0.5) * this.options.velocitySpread.x,
            this.options.velocity.y + (Math.random() - 0.5) * this.options.velocitySpread.y,
            this.options.velocity.z + (Math.random() - 0.5) * this.options.velocitySpread.z
        );

        // Age and Lifetime
        this.ages[index] = 0;
        this.lifetimes[index] = this.options.lifetime * (0.5 + Math.random() * 0.5); // Vary lifetime slightly
    }

    update(deltaTime) {
        let needsRespawn = 0;
        for (let i = 0; i < this.options.particleCount; i++) {
            this.ages[i] += deltaTime;
            if (this.ages[i] >= this.lifetimes[i]) {
                // Particle is dead, mark for respawn
                this.positions[i * 3 + 1] = -9999; // Move off-screen
                needsRespawn++;
                continue; // Skip update for dead particle
            }

            const i3 = i * 3;

            // Update position based on velocity and gravity
            this.velocities[i].y += this.options.gravity * deltaTime; // Apply gravity
            this.positions[i3 + 0] += this.velocities[i].x * deltaTime;
            this.positions[i3 + 1] += this.velocities[i].y * deltaTime;
            this.positions[i3 + 2] += this.velocities[i].z * deltaTime;

            // Fade out (optional) - Adjust opacity via material or shader later if needed
            // For now, color attribute alpha isn't directly used by PointsMaterial opacity
            // Could fade color to black instead
            const lifeRatio = this.ages[i] / this.lifetimes[i];
            const fadeFactor = 1.0 - lifeRatio;
            // Example: Fade color - This requires vertexColors to be effective
             this.colors[i3 + 0] *= fadeFactor;
             this.colors[i3 + 1] *= fadeFactor;
             this.colors[i3 + 2] *= fadeFactor;
        }

        // Respawn dead particles
        let respawnCounter = 0;
        if (needsRespawn > 0) {
            for (let i = 0; i < this.options.particleCount && respawnCounter < needsRespawn * 2 * deltaTime; i++) { // Spawn based on time passed
                 if (this.ages[i] >= this.lifetimes[i]) {
                     this.spawnParticle(i);
                     respawnCounter++;
                 }
             }
        }


        // Update geometry attributes
        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
    }

    dispose() {
        this.parent.remove(this.points);
        this.geometry.dispose();
        this.material.dispose();
        // Dispose texture if loaded
    }
}
```

```
// js/pier.js
import * as THREE from 'three';
import { createStandardMaterial, createBoxGeometry, createCylinderGeometry, createPlaneGeometry } from './utils.js';

export class Pier {
    constructor(scene) {
        this.scene = scene;
        this.createPier();
        this.createWater();
    }

    createWater() {
        // Create water plane
        const waterGeometry = createPlaneGeometry(200, 200);
        const waterMaterial = createStandardMaterial(0x0077ff, 0.3, 0.2, 0x003366, 0.2);
        waterMaterial.side = THREE.DoubleSide;
        waterMaterial.transparent = true;
        waterMaterial.opacity = 0.8;
        
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -0.1;
        this.scene.add(water);

        // Add grid helper
        const gridHelper = new THREE.GridHelper(200, 200, 0x00ffff, 0x00ffff);
        gridHelper.position.y = -0.09; // Slightly above the water
        gridHelper.material.transparent = true;
        gridHelper.material.opacity = 0.3;
        this.scene.add(gridHelper);
    }

    createPier() {
        // Create pier group
        this.pierGroup = new THREE.Group();
        
        // Main pier platform
        const pierGeometry = createBoxGeometry(40, 0.5, 20);
        const pierMaterial = createStandardMaterial(0x8B4513, 0.7, 0.2);
        pierMaterial.side = THREE.DoubleSide;
        pierMaterial.depthWrite = true;
        pierMaterial.depthTest = true;
        
        const pierPlatform = new THREE.Mesh(pierGeometry, pierMaterial);
        pierPlatform.position.y = 0;
        pierPlatform.renderOrder = 1;
        pierPlatform.userData.isCollidable = true;
        this.pierGroup.add(pierPlatform);
        
        // Create pier supports
        const supportGeometry = createCylinderGeometry(0.2, 0.2, 1, 8);
        const supportMaterial = createStandardMaterial(0x6B3E14, 0.8);
        
        // Add supports at corners and middle
        const supportPositions = [
            // Front supports
            [-20, -0.25, 10], [-10, -0.25, 10], [0, -0.25, 10], [10, -0.25, 10], [20, -0.25, 10],
            // Back supports
            [-20, -0.25, -10], [-10, -0.25, -10], [0, -0.25, -10], [10, -0.25, -10], [20, -0.25, -10],
            // Middle supports
            [-20, -0.25, 0], [-10, -0.25, 0], [0, -0.25, 0], [10, -0.25, 0], [20, -0.25, 0],
            // Additional supports for stability
            [-15, -0.25, 5], [-5, -0.25, 5], [5, -0.25, 5], [15, -0.25, 5],
            [-15, -0.25, -5], [-5, -0.25, -5], [5, -0.25, -5], [15, -0.25, -5]
        ];
        
        supportPositions.forEach(pos => {
            const support = new THREE.Mesh(supportGeometry, supportMaterial);
            support.position.set(pos[0], pos[1], pos[2]);
            this.pierGroup.add(support);
        });
        
        // Add railings
        this.addRailings();
        
        // Add pier to scene
        this.scene.add(this.pierGroup);
    }

    addRailings() {
        // Railing material with emissive for neon effect
        const railingMaterial = createStandardMaterial(0x333333, 0.5, 0.8, 0x00ffff, 0.2);
        
        // Top railing
        const topRailingGeometry = createBoxGeometry(40, 0.1, 0.1);
        const frontTopRailing = new THREE.Mesh(topRailingGeometry, railingMaterial);
        frontTopRailing.position.set(0, 1.25, 10);
        frontTopRailing.userData.isCollidable = true;
        this.pierGroup.add(frontTopRailing);
        
        const backTopRailing = new THREE.Mesh(topRailingGeometry, railingMaterial);
        backTopRailing.position.set(0, 1.25, -10);
        backTopRailing.userData.isCollidable = true;
        this.pierGroup.add(backTopRailing);
        
        const leftTopRailing = new THREE.Mesh(createBoxGeometry(0.1, 0.1, 20), railingMaterial);
        leftTopRailing.position.set(-20, 1.25, 0);
        leftTopRailing.userData.isCollidable = true;
        this.pierGroup.add(leftTopRailing);
        
        const rightTopRailing = new THREE.Mesh(createBoxGeometry(0.1, 0.1, 20), railingMaterial);
        rightTopRailing.position.set(20, 1.25, 0);
        rightTopRailing.userData.isCollidable = true;
        this.pierGroup.add(rightTopRailing);
        
        // Vertical posts
        const postGeometry = createBoxGeometry(0.1, 1, 0.1);
        const postPositions = [
            // Front posts
            [-20, 0.75, 10], [-15, 0.75, 10], [-10, 0.75, 10], [-5, 0.75, 10],
            [0, 0.75, 10], [5, 0.75, 10], [10, 0.75, 10], [15, 0.75, 10], [20, 0.75, 10],
            // Back posts
            [-20, 0.75, -10], [-15, 0.75, -10], [-10, 0.75, -10], [-5, 0.75, -10],
            [0, 0.75, -10], [5, 0.75, -10], [10, 0.75, -10], [15, 0.75, -10], [20, 0.75, -10],
            // Side posts
            [-20, 0.75, 0], [-20, 0.75, -5], [-20, 0.75, 5],
            [20, 0.75, 0], [20, 0.75, -5], [20, 0.75, 5]
        ];
        
        postPositions.forEach(pos => {
            const post = new THREE.Mesh(postGeometry, railingMaterial);
            post.position.set(pos[0], pos[1], pos[2]);
            post.userData.isCollidable = true;
            this.pierGroup.add(post);
        });
    }
} 
```

```
// js/portal.js
// Portal.js
import * as THREE from 'three';
import { createStandardMaterial } from './utils.js'; // Assuming this exists
import { ParticleSystem } from './ParticleSystem.js'; // Fixed case sensitivity

export class Portal {
    constructor(scene, position, size, targetSceneName, targetSpawnPoint) {
        this.scene = scene; // The scene this portal instance lives in
        this.position = position;
        this.size = size; // Controls overall scale
        this.targetSceneName = targetSceneName; // e.g., 'waitingRoom' or 'mainArea'
        this.targetSpawnPoint = targetSpawnPoint; // THREE.Vector3 where character appears
        this.activationRadius = size * 1.5; // How close the player needs to be

        // Create portal visuals directly in the scene
        this.createPortalVisuals();
    }

    createPortalVisuals() {
        // Create portal group
        this.portalGroup = new THREE.Group();
        this.portalGroup.position.copy(this.position);
        
        // Create outer ring with improved material
        const outerRingGeometry = new THREE.TorusGeometry(0.5 * this.size, 0.1 * this.size, 32, 100);
        const outerRingMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff9d,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0x00ff9d,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
        });
        this.outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
        this.portalGroup.add(this.outerRing);
        
        // Create inner ring with sheen effect
        const innerRingGeometry = new THREE.TorusGeometry(0.4 * this.size, 0.05 * this.size, 32, 100);
        const innerRingMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 1.0,
            roughness: 0.1,
            emissive: 0xffffff,
            emissiveIntensity: 0.8,
            transparent: true,
            opacity: 0.9
        });
        this.innerRing = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
        this.portalGroup.add(this.innerRing);
        
        // Create portal core with dynamic sheen
        const coreGeometry = new THREE.CircleGeometry(0.35 * this.size, 32);
        const coreMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff9d,
            metalness: 0.9,
            roughness: 0.1,
            emissive: 0x00ff9d,
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        this.portalCore = new THREE.Mesh(coreGeometry, coreMaterial);
        this.portalCore.rotation.x = -Math.PI / 2; // Rotate to face forward
        this.portalGroup.add(this.portalCore);
        
        // Create portal glow effect
        const glowGeometry = new THREE.CircleGeometry(0.5 * this.size, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff9d,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        this.portalGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        this.portalGlow.rotation.x = -Math.PI / 2; // Rotate to face forward
        this.portalGroup.add(this.portalGlow);
        
        // Create particle system with more dynamic particles
        this.particleSystem = new ParticleSystem(
            this.scene,
            this.portalGroup.position,
            50, // Increased particle count
            [0x00ff9d, 0xffffff, 0x00cc7d], // Multiple colors
            0.1 * this.size, // Scale particle size with portal size
            0.5, // Faster particle speed
            2.0, // Longer particle lifetime
            0.8, // Higher particle opacity
            0.5  // More spread
        );
        
        // Add portal group to scene
        this.scene.add(this.portalGroup);
    }

    // Check if character is close enough to activate
    checkForActivation(characterPosition) {
        return this.position.distanceTo(characterPosition) < this.activationRadius;
    }

    // Get destination info
    getTarget() {
        return {
            sceneName: this.targetSceneName,
            spawnPoint: this.targetSpawnPoint.clone() // Clone to prevent accidental modification
        };
    }

    // Update animations (like sparks)
    update(deltaTime) {
        if (!this.portalGroup) return;
        
        // Update portal rotation
        this.portalGroup.rotation.y += deltaTime * 0.5;
        
        // Update inner ring sheen effect
        if (this.innerRing) {
            this.innerRing.material.emissiveIntensity = 0.8 + Math.sin(Date.now() * 0.003) * 0.2;
        }
        
        // Update portal core glow
        if (this.portalCore) {
            this.portalCore.material.emissiveIntensity = 0.7 + Math.sin(Date.now() * 0.002) * 0.3;
            this.portalCore.material.opacity = 0.8 + Math.sin(Date.now() * 0.001) * 0.1;
        }
        
        // Update glow effect
        if (this.portalGlow) {
            this.portalGlow.material.opacity = 0.3 + Math.sin(Date.now() * 0.001) * 0.1;
        }
        
        // Update particle system
        if (this.particleSystem) {
            this.particleSystem.update(deltaTime);
        }
    }

    // Remove from scene (if needed)
    dispose() {
        if (this.particleSystem) {
            this.particleSystem.dispose();
        }
        if (this.portalGroup) {
            this.scene.remove(this.portalGroup);
        }
    }
}
```

```
// js/speechBubble.js
import * as THREE from 'three';

export class SpeechBubble {
    constructor(scene, text, lifespan = 5000) {
        this.scene = scene;
        this.text = text;
        this.lifespan = lifespan;
        this.creationTime = Date.now();
        this.createBubble();
        this.initialOpacity = 0;
        this.targetOpacity = 1;
        this.fadeInDuration = 200; // 200ms fade in
    }

    createBubble() {
        // Create container group
        this.group = new THREE.Group();

        // Create background plane for text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Set canvas size (smaller for better resolution)
        canvas.width = 256;
        canvas.height = 128;
        
        // Draw background with solid color
        context.fillStyle = '#000000';
        this.roundRect(context, 2, 2, canvas.width - 4, canvas.height - 4, 10);
        context.fill();
        
        // Draw border
        context.strokeStyle = '#00ff9d';
        context.lineWidth = 2;
        this.roundRect(context, 2, 2, canvas.width - 4, canvas.height - 4, 10);
        context.stroke();
        
        // Draw text with improved font and size
        context.font = 'bold 32px Arial';
        context.fillStyle = '#00ff9d';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Word wrap text with improved spacing
        const words = this.text.split(' ');
        let line = '';
        let lines = [];
        const maxWidth = canvas.width - 40;
        const lineHeight = 40;

        for (let word of words) {
            // Check if the word itself is too long
            const wordMetrics = context.measureText(word);
            if (wordMetrics.width > maxWidth) {
                // Handle very long words (e.g., truncate or split - here we truncate)
                // A more sophisticated approach might split the word
                console.warn(`Word "${word}" is too long for the speech bubble.`);
                // Basic truncation: find how many chars fit
                let truncatedWord = '';
                for (let k = 1; k <= word.length; k++) {
                    if (context.measureText(truncatedWord + word[k]).width > maxWidth) {
                        break;
                    }
                    truncatedWord += word[k];
                }
                 // If even the first char is too long, use a placeholder
                 if (truncatedWord === '') {
                    word = '...'; 
                 } else {
                    word = truncatedWord + '...';
                 }
            }

            const testLine = line + word + ' ';
            const metrics = context.measureText(testLine);
            
            if (metrics.width > maxWidth && line !== '') {
                lines.push(line);
                line = word + ' ';
            } else {
                line = testLine;
            }
        }
        lines.push(line);

        // Draw each line with improved positioning
        lines.forEach((line, i) => {
            context.fillText(
                line.trim(),
                canvas.width / 2,
                (canvas.height / 2) - ((lines.length - 1) * lineHeight / 2) + (i * lineHeight)
            );
        });

        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        // Create speech bubble plane with adjusted size
        const geometry = new THREE.PlaneGeometry(2.4, 1.2);
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        this.bubble = new THREE.Mesh(geometry, material);
        
        // Create pointer triangle
        const triangleGeometry = new THREE.BufferGeometry();
        const triangleVertices = new Float32Array([
            -0.05, -0.2, 0,  // bottom left
             0.05, -0.2, 0,  // bottom right
             0.0, -0.3, 0   // point
        ]);
        triangleGeometry.setAttribute('position', new THREE.BufferAttribute(triangleVertices, 3));
        const triangleMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        
        // Add stroke to triangle
        const triangleStrokeGeometry = new THREE.BufferGeometry();
        const strokeVertices = new Float32Array([
            -0.05, -0.2, 0,
             0.05, -0.2, 0,
             0.0, -0.3, 0,
            -0.05, -0.2, 0  // Close the triangle
        ]);
        triangleStrokeGeometry.setAttribute('position', new THREE.BufferAttribute(strokeVertices, 3));
        const triangleStrokeMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff9d,
            transparent: true,
            opacity: 1
        });

        const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
        const triangleStroke = new THREE.Line(triangleStrokeGeometry, triangleStrokeMaterial);

        // Add meshes to group
        this.group.add(this.bubble);
        this.group.add(triangle);
        this.group.add(triangleStroke);

        // Position above character with increased height
        this.group.position.y = 2.5; // Increased from 2.2 to 2.5
        this.group.position.z = 0.2; // Slight forward offset
        
        // Add to scene
        this.scene.add(this.group);
    }

    roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }

    update(characterPosition, camera) {
        if (!this.group) return false;

        // Update position to follow character with increased height
        this.group.position.x = characterPosition.x;
        this.group.position.y = characterPosition.y + 2.5; // Increased from 2.2 to 2.5
        this.group.position.z = characterPosition.z + 0.2; // Keep forward offset

        // Make bubble face camera with slight tilt
        this.group.quaternion.copy(camera.quaternion);
        this.group.rotation.x += 0.1; // Slight upward tilt

        // Handle fade in
        const age = Date.now() - this.creationTime;
        if (age < this.fadeInDuration) {
            this.initialOpacity = age / this.fadeInDuration;
            this.bubble.material.opacity = this.initialOpacity;
            this.group.children[1].material.opacity = this.initialOpacity;
            this.group.children[2].material.opacity = this.initialOpacity;
        } else {
            this.bubble.material.opacity = this.targetOpacity;
            this.group.children[1].material.opacity = this.targetOpacity;
            this.group.children[2].material.opacity = this.targetOpacity;
        }

        // Check if lifetime is expired
        if (age >= this.lifespan) {
            this.remove();
            return false;
        }

        // Fade out near end of life
        const fadeStart = this.lifespan - 300;
        if (age > fadeStart) {
            const opacity = 1 - ((age - fadeStart) / 300);
            this.bubble.material.opacity = opacity;
            this.group.children[1].material.opacity = opacity;
            this.group.children[2].material.opacity = opacity;
        }

        return true;
    }

    remove() {
        if (this.group && this.group.parent) {
            this.scene.remove(this.group);
            this.bubble.material.dispose();
            this.bubble.geometry.dispose();
            this.group.children[1].material.dispose();
            this.group.children[1].geometry.dispose();
            this.group.children[2].material.dispose();
            this.group.children[2].geometry.dispose();
        }
    }
} 
```

```
// js/titleScreen.js
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

// Custom Chromatic Aberration Shader (remains the same)
const ChromaticAberrationShader = {
    uniforms: {
        "tDiffuse": { value: null },
        "amount": { value: 0.003 },
        "angle": { value: 0.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;
        
        void main() {
            vec2 offset = amount * vec2(cos(angle), sin(angle));
            vec4 cr = texture2D(tDiffuse, vUv + offset);
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - offset);
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a); // Use cg.a for alpha
        }
    `
};

// EMO WORLD AESTHETIC CONSTANTS - ADJUSTED FOR MORE VISIBILITY
const EMO_COLORS = {
    SKY_TOP: new THREE.Color(0x121228), // Slightly lighter dark inky purple-blue
    SKY_BOTTOM: new THREE.Color(0x180D24), // Slightly lighter deeper purple
    FOG: new THREE.Color(0x1A182C), // Lighter, less dense purplish fog
    NEON_PINK: new THREE.Color(0xff00ff),
    NEON_CYAN: new THREE.Color(0x00ffff),
    NEON_PURPLE: new THREE.Color(0x8a2be2),
    NEON_BLUE: new THREE.Color(0x0077ff),
    DIGITAL_RAIN_COLOR: new THREE.Color(0x00ffaa),
    BUILDING_BASE: new THREE.Color(0x2A2D3A), // Noticeably lighter base for buildings
    BUILDING_EMISSIVE: new THREE.Color(0x08080C), // Slightly more emissive
    BALCONY_COLOR: new THREE.Color(0x282830), // Slightly lighter balcony
    MOON_VISUAL_COLOR: new THREE.Color(0xC0C0E8), // Pale lavender/blue moon
    MOON_EMISSIVE_COLOR: new THREE.Color(0x9090C0), // Emissive part of the moon
    MOON_LIGHT_COLOR: new THREE.Color(0xD0D8E8), // Lighter, stronger moonlight
    FILL_LIGHT_COLOR: new THREE.Color(0x504A65), // Lighter moody purple for fill
};

export class TitleScreen {
    constructor(container) {
        this.container = container;
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.composer = null;
        this.rainParticles = [];
        this.digitalRainParticles = null;
        this.neonLights = [];
        this.holographicAds = [];
        this.titleMesh = null;
        this.menuItemMeshes = [];
        this.fontLoader = new FontLoader();
        this.moonMesh = null;
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.hoveredMenuItem = null;

        this.init();
        this.setupEventListeners();
    }

    init() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        // Optional: Tone mapping can help manage very bright lights and dark shadows
        // this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // this.renderer.toneMappingExposure = 1.0;
        this.container.appendChild(this.renderer.domElement);

        this.camera.position.set(0, 5, 15);
        this.camera.lookAt(0, 1, -10);

        // Significantly reduced fog density
        this.scene.fog = new THREE.FogExp2(EMO_COLORS.FOG, 0.010);

        this.setupLighting();
        this.setupPostProcessing();

        this.createBackground();
        this.createCityscape();
        this.createForegroundBalcony();
        this.createRain();
        this.createDigitalRain();

        this.loadFontsAndCreateTextElements();

        this.animate();

        window.addEventListener('resize', () => this.onWindowResize());
    }

    setupPostProcessing() {
        this.composer = new EffectComposer(this.renderer);
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.7,  // Bloom strength
            0.5,  // Bloom radius
            0.65  // Bloom threshold (lower means more things bloom)
        );
        this.composer.addPass(bloomPass);

        const chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
        chromaticAberrationPass.uniforms.amount.value = 0.0015;
        this.composer.addPass(chromaticAberrationPass);
    }

    setupLighting() {
        // Significantly increased ambient light
        const ambientLight = new THREE.AmbientLight(EMO_COLORS.FOG, 2.0); // Was 0.9
        this.scene.add(ambientLight);

        // Main "Moon" light source - significantly stronger
        const moonLight = new THREE.DirectionalLight(EMO_COLORS.MOON_LIGHT_COLOR, 3.0); // Was 1.2
        moonLight.position.set(-0.7, 0.8, -1).normalize();
        this.scene.add(moonLight);

        // Fill light - stronger and better aimed
        const fillLight = new THREE.DirectionalLight(EMO_COLORS.FILL_LIGHT_COLOR, 1.5); // Was 0.5
        fillLight.position.set(0.7, 0.5, -1.0).normalize(); // Aimed more towards the city
        this.scene.add(fillLight);

        // Foreground light
        const cameraLight = new THREE.PointLight(EMO_COLORS.NEON_CYAN, 0.6, 25); // Slightly stronger
        cameraLight.position.set(0, 2, 10);
        this.scene.add(cameraLight);
    }

    createBackground() {
        const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: EMO_COLORS.SKY_TOP },
                bottomColor: { value: EMO_COLORS.SKY_BOTTOM }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(0.0, h) * 0.8 + 0.2), 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        this.scene.add(sky);

        const moonGeometry = new THREE.SphereGeometry(25, 32, 32); // Slightly larger moon
        const moonMaterial = new THREE.MeshStandardMaterial({
            color: EMO_COLORS.MOON_VISUAL_COLOR,
            emissive: EMO_COLORS.MOON_EMISSIVE_COLOR,
            emissiveIntensity: 1.5, // More glow
            fog: false
        });
        this.moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
        this.moonMesh.position.set(-150, 80, -350); // Positioned further and slightly larger
        this.scene.add(this.moonMesh);
    }

    createCityscape() {
        const buildingGeometry = new THREE.BoxGeometry(1, 1, 1);
        const numBuildings = 50;
        const citySpread = 150;

        for (let i = 0; i < numBuildings; i++) {
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: EMO_COLORS.BUILDING_BASE, // Uses new, lighter base color
                metalness: 0.2, // Less metalness, more diffuse reflection
                roughness: 0.7, // More roughness
                emissive: EMO_COLORS.BUILDING_EMISSIVE,
                emissiveIntensity: 0.5 // Slightly increased building self-glow
            });

            const height = 10 + Math.random() * 80;
            const width = 3 + Math.random() * 8;
            const depth = 3 + Math.random() * 8;

            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.scale.set(width, height, depth);
            building.position.set(
                (Math.random() - 0.5) * citySpread,
                height / 2 - 10,
                -(20 + Math.random() * (citySpread / 2))
            );
            this.scene.add(building);

            if (Math.random() < 0.7) {
                this.addNeonAccentToBuilding(building);
            }

            if (height > 40 && Math.random() < 0.3) {
                this.addHolographicAd(building);
            }
        }
    }

    addNeonAccentToBuilding(building) {
        const neonColors = [EMO_COLORS.NEON_PINK, EMO_COLORS.NEON_CYAN, EMO_COLORS.NEON_PURPLE, EMO_COLORS.NEON_BLUE];
        const color = neonColors[Math.floor(Math.random() * neonColors.length)];

        // Neon point lights now stronger to stand out against brighter scene
        const accentLight = new THREE.PointLight(color, 3.0, 18 + Math.random() * 12); // Was 2.0 intensity
        accentLight.position.set(
            building.position.x + (Math.random() - 0.5) * building.scale.x * 0.5,
            building.position.y + (Math.random() - 0.5) * building.scale.y * 0.8,
            building.position.z + (Math.random() > 0.5 ? building.scale.z / 2 : -building.scale.z / 2)
        );
        this.scene.add(accentLight);
        this.neonLights.push({light: accentLight, baseIntensity: accentLight.intensity, flickerSpeed: 0.001 + Math.random() * 0.005});

        const sourceGeo = new THREE.SphereGeometry(0.15 + Math.random() * 0.2, 8, 8); // Slightly larger sources
        const sourceMat = new THREE.MeshBasicMaterial({ color: color, emissive: color });
        const sourceMesh = new THREE.Mesh(sourceGeo, sourceMat);
        sourceMesh.position.copy(accentLight.position);
        this.scene.add(sourceMesh);
        this.neonLights.push({mesh: sourceMesh, flickerSpeed: 0.002 + Math.random() * 0.005});
    }

    addHolographicAd(building) {
        const adWidth = building.scale.x * (0.5 + Math.random() * 0.5);
        const adHeight = building.scale.y * (0.2 + Math.random() * 0.3);
        const adGeometry = new THREE.PlaneGeometry(adWidth, adHeight);
        
        const holographicAdMaterial = new THREE.MeshBasicMaterial({
            color: Math.random() > 0.5 ? EMO_COLORS.NEON_CYAN : EMO_COLORS.NEON_PINK,
            transparent: true,
            opacity: 0.4 + Math.random() * 0.3, // Slightly more opaque
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
        });

        const ad = new THREE.Mesh(adGeometry, holographicAdMaterial);
        ad.position.set(
            building.position.x,
            building.position.y + building.scale.y * 0.25 * (Math.random() - 0.5),
            building.position.z + (building.scale.z / 2 + 0.1) * (Math.random() > 0.5 ? 1 : -1)
        );
        ad.lookAt(this.camera.position);
        this.scene.add(ad);
        this.holographicAds.push(ad);
    }

    createRain() {
        const rainCount = 5000;
        const positions = new Float32Array(rainCount * 3);
        const velocities = new Float32Array(rainCount);

        for (let i = 0; i < rainCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 80;
            positions[i * 3 + 1] = Math.random() * 60;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 80 - 20;
            velocities[i] = 0.2 + Math.random() * 0.3;
        }

        const rainGeometry = new THREE.BufferGeometry();
        rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const rainMaterial = new THREE.PointsMaterial({
            color: 0x8899AA, // Slightly lighter rain
            size: 0.08,
            transparent: true,
            opacity: 0.5, // Slightly more opaque
            sizeAttenuation: true,
        });

        const rain = new THREE.Points(rainGeometry, rainMaterial);
        this.scene.add(rain);
        this.rainParticles.push({ points: rain, velocities: velocities, type: 'normal' });
    }

    createDigitalRain() {
        const particleCount = 300;
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 60;
            positions[i * 3 + 1] = Math.random() * 50;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 60 - 15;
            velocities[i] = 0.05 + Math.random() * 0.05;
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: EMO_COLORS.DIGITAL_RAIN_COLOR,
            size: 0.15,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
        });
        this.digitalRainParticles = new THREE.Points(geometry, material);
        this.scene.add(this.digitalRainParticles);
        this.digitalRainParticles.userData.velocities = velocities;
    }

    loadFontsAndCreateTextElements() {
        this.fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (font) => {
            const textGeometry = new TextGeometry('EMO WORLD', {
                font: font,
                size: 1.2,
                height: 0.1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.03,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 5
            });
            textGeometry.center();

            const textMaterial = new THREE.MeshStandardMaterial({
                color: EMO_COLORS.NEON_PINK,
                emissive: EMO_COLORS.NEON_PINK,
                emissiveIntensity: 1.0,
                metalness: 0.1,
                roughness: 0.5,
            });
            this.titleMesh = new THREE.Mesh(textGeometry, textMaterial);
            this.titleMesh.position.set(0, 6, -2);
            this.scene.add(this.titleMesh);
        }, undefined, (err) => console.error('Error loading title font:', err));

        const menuItems = ['ENTER', 'SETTINGS', 'ABOUT'];
        this.fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            menuItems.forEach((text, index) => {
                const itemGeometry = new TextGeometry(text, {
                    font: font,
                    size: 0.35,
                    height: 0.05,
                    curveSegments: 4,
                    bevelEnabled: false
                });
                itemGeometry.center();

                const itemMaterial = new THREE.MeshStandardMaterial({
                    color: 0xeeeeff,
                    emissive: 0xaaaacc,
                    emissiveIntensity: 0.5,
                });
                const textMesh = new THREE.Mesh(itemGeometry, itemMaterial);
                textMesh.position.set(0, 3.5 - index * 0.7, 0);
                textMesh.userData.text = text; // Store the menu text for click handling
                this.scene.add(textMesh);
                this.menuItemMeshes.push(textMesh);
            });
        }, undefined, (err) => console.error('Error loading menu font:', err));
    }

    createForegroundBalcony() {
        const mainRailGeo = new THREE.BoxGeometry(12, 0.2, 0.2);
        const supportGeo = new THREE.BoxGeometry(0.2, 2, 0.2);
        const balconyMaterial = new THREE.MeshStandardMaterial({
            color: EMO_COLORS.BALCONY_COLOR,
            metalness: 0.5,
            roughness: 0.5,
        });

        const mainRail = new THREE.Mesh(mainRailGeo, balconyMaterial);
        mainRail.position.set(0, 0.5, 5);
        this.scene.add(mainRail);

        const supportLeft = new THREE.Mesh(supportGeo, balconyMaterial);
        supportLeft.position.set(-5.8, -0.5, 5);
        this.scene.add(supportLeft);

        const supportRight = new THREE.Mesh(supportGeo, balconyMaterial);
        supportRight.position.set(5.8, -0.5, 5);
        this.scene.add(supportRight);
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.composer.setSize(window.innerWidth, window.innerHeight);
    }

    setupEventListeners() {
        window.addEventListener('mousemove', (event) => {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('click', (event) => {
            if (this.hoveredMenuItem) {
                const menuText = this.hoveredMenuItem.userData.text;
                switch (menuText) {
                    case 'ENTER':
                        // Dispatch custom event for game start
                        window.dispatchEvent(new CustomEvent('startGame'));
                        break;
                    case 'SETTINGS':
                        // TODO: Implement settings menu
                        console.log('Settings clicked');
                        break;
                    case 'ABOUT':
                        // TODO: Implement about screen
                        console.log('About clicked');
                        break;
                }
            }
        });
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        const time = Date.now();
        const slowTime = time * 0.0001;

        // Update raycaster
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.menuItemMeshes);

        // Handle hover effects
        if (intersects.length > 0) {
            const hoveredMesh = intersects[0].object;
            if (this.hoveredMenuItem !== hoveredMesh) {
                // Reset previous hover
                if (this.hoveredMenuItem) {
                    this.hoveredMenuItem.material.emissiveIntensity = 0.5;
                    this.hoveredMenuItem.scale.set(1, 1, 1);
                }
                // Set new hover
                this.hoveredMenuItem = hoveredMesh;
                this.hoveredMenuItem.material.emissiveIntensity = 1.0;
                this.hoveredMenuItem.scale.set(1.1, 1.1, 1.1);
            }
        } else if (this.hoveredMenuItem) {
            // Reset hover when mouse leaves menu item
            this.hoveredMenuItem.material.emissiveIntensity = 0.5;
            this.hoveredMenuItem.scale.set(1, 1, 1);
            this.hoveredMenuItem = null;
        }

        this.camera.position.x = Math.sin(slowTime * 0.3) * 0.5;
        this.camera.position.y = 5 + Math.cos(slowTime * 0.2) * 0.2;
        this.camera.lookAt(0, 1 + Math.sin(slowTime * 0.1) * 0.5, -10);

        this.rainParticles.forEach(particleSystem => {
            const positions = particleSystem.points.geometry.attributes.position.array;
            const velocities = particleSystem.velocities;
            for (let i = 0; i < velocities.length; i++) {
                positions[i * 3 + 1] -= velocities[i];
                if (positions[i * 3 + 1] < -10) {
                    positions[i * 3 + 1] = 50 + Math.random() * 10;
                }
            }
            particleSystem.points.geometry.attributes.position.needsUpdate = true;
        });

        if (this.digitalRainParticles) {
            const positions = this.digitalRainParticles.geometry.attributes.position.array;
            const velocities = this.digitalRainParticles.userData.velocities;
            for (let i = 0; i < velocities.length; i++) {
                positions[i * 3 + 1] -= velocities[i];
                if (positions[i * 3 + 1] < -5) {
                    positions[i * 3 + 1] = 40 + Math.random() * 10;
                }
            }
            this.digitalRainParticles.geometry.attributes.position.needsUpdate = true;
            this.digitalRainParticles.material.opacity = 0.5 + Math.sin(time * 0.005 + Math.random()) * 0.2;
        }

        this.neonLights.forEach(item => {
            if (item.light) {
                item.light.intensity = item.baseIntensity * (0.8 + Math.sin(time * item.flickerSpeed + Math.random() * Math.PI) * 0.2);
                if (Math.random() < 0.005) {
                    item.light.intensity = item.baseIntensity * 0.1;
                }
            } else if (item.mesh && item.mesh.material.emissive) {
                 item.mesh.material.opacity = (0.6 + Math.sin(time * item.flickerSpeed * 2.0 + Math.random() * Math.PI) * 0.4);
            }
        });

        this.holographicAds.forEach(ad => {
            ad.material.opacity = 0.3 + Math.sin(time * 0.002 + ad.uuid.length) * 0.2;
            if (Math.random() < 0.01) {
                ad.position.x += (Math.random() - 0.5) * 0.1;
                ad.position.y += (Math.random() - 0.5) * 0.1;
            }
        });

        if (this.titleMesh && this.titleMesh.material.emissive) {
            this.titleMesh.material.emissiveIntensity = 0.9 + Math.sin(time * 0.0015) * 0.3;
            this.titleMesh.rotation.y = Math.sin(time * 0.0002) * 0.01;
            this.titleMesh.rotation.x = Math.cos(time * 0.00023) * 0.005;
        }
        this.menuItemMeshes.forEach(item => {
             if (item.material.emissive) {
                 item.material.emissiveIntensity = 0.4 + Math.sin(time * 0.001 + item.uuid.length) * 0.2;
             }
        });

        if (this.composer) {
            const chromaticAberrationPass = this.composer.passes.find(pass => pass.uniforms && pass.uniforms.amount);
            if (chromaticAberrationPass) {
                chromaticAberrationPass.uniforms.angle.value = slowTime * 0.5;
                chromaticAberrationPass.uniforms.amount.value = 0.0015 + Math.abs(Math.sin(time * 0.0003)) * 0.003;
            }
        }

        this.composer.render();
    }
}
```

```
// js/utils.js
import * as THREE from 'three';

// Utility functions for the EBOY Pier scene

export function createStandardMaterial(color, roughness = 0.7, metalness = 0.2, emissive = 0x000000, emissiveIntensity = 0) {
    return new THREE.MeshStandardMaterial({
        color: color,
        roughness: roughness,
        metalness: metalness,
        emissive: emissive,
        emissiveIntensity: emissiveIntensity
    });
}

export function createBoxGeometry(width, height, depth) {
    return new THREE.BoxGeometry(width, height, depth);
}

export function createCylinderGeometry(radiusTop, radiusBottom, height, radialSegments = 8) {
    return new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments);
}

export function createSphereGeometry(radius, widthSegments = 16, heightSegments = 16) {
    return new THREE.SphereGeometry(radius, widthSegments, heightSegments);
}

export function createPlaneGeometry(width, height) {
    return new THREE.PlaneGeometry(width, height);
} 
```

```
// js/vinyl.js
import * as THREE from 'three';

export class Vinyl {
    constructor(scene, position, direction) {
        this.scene = scene;
        this.speed = 15;
        this.lifespan = 2; // Seconds before disappearing
        this.timeAlive = 0;
        this.isActive = true;
        this.gravity = 9.8; // Gravity constant
        this.velocity = new THREE.Vector3(
            direction.x * this.speed,
            0,
            direction.z * this.speed
        );
        
        // Create vinyl geometry
        const vinylGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.02, 32);
        
        // Create materials for both sides of the vinyl
        const vinylMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000,
            metalness: 0.8,
            roughness: 0.2,
            side: THREE.DoubleSide
        });
        
        // Create the vinyl mesh
        this.mesh = new THREE.Mesh(vinylGeometry, vinylMaterial);
        
        // Add grooves (rings) to the vinyl
        const grooveCount = 8;
        for (let i = 1; i <= grooveCount; i++) {
            const radius = (i / grooveCount) * 0.18;
            const grooveGeometry = new THREE.RingGeometry(radius, radius + 0.01, 32);
            const grooveMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                side: THREE.DoubleSide
            });
            const groove = new THREE.Mesh(grooveGeometry, grooveMaterial);
            groove.rotation.x = Math.PI / 2;
            groove.position.y = 0.011; // Slightly above the vinyl surface
            this.mesh.add(groove);
            
            // Add groove to bottom side
            const bottomGroove = groove.clone();
            bottomGroove.position.y = -0.011;
            this.mesh.add(bottomGroove);
        }
        
        // Add center hole
        const holeGeometry = new THREE.CircleGeometry(0.02, 16);
        const holeMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            side: THREE.DoubleSide
        });
        const hole = new THREE.Mesh(holeGeometry, holeMaterial);
        hole.rotation.x = Math.PI / 2;
        hole.position.y = 0.011;
        this.mesh.add(hole);
        
        // Add hole to bottom side
        const bottomHole = hole.clone();
        bottomHole.position.y = -0.011;
        this.mesh.add(bottomHole);
        
        // Position and rotate the vinyl
        this.mesh.position.copy(position);
        this.mesh.rotation.x = Math.PI / 2; // Make it vertical
        
        // Add to scene
        this.scene.add(this.mesh);
    }
    
    update(deltaTime) {
        if (!this.isActive) return false;

        // Apply gravity to velocity
        this.velocity.y -= this.gravity * deltaTime;
        
        // Update position based on velocity
        this.mesh.position.x += this.velocity.x * deltaTime;
        this.mesh.position.y += this.velocity.y * deltaTime;
        this.mesh.position.z += this.velocity.z * deltaTime;
        
        // Rotate the vinyl
        this.mesh.rotation.y += 15 * deltaTime; // Spin animation
        
        // Check if vinyl hit the ground
        if (this.mesh.position.y <= 0) {
            this.mesh.position.y = 0;
            this.velocity.y = 0;
            this.velocity.x *= 0.8; // Friction
            this.velocity.z *= 0.8; // Friction
        }
        
        // Update lifespan
        this.timeAlive += deltaTime;
        
        // Check if vinyl should be removed
        if (this.timeAlive >= this.lifespan) {
            this.dispose();
            return false;
        }
        
        return true;
    }
    
    dispose() {
        if (this.mesh) {
            // Remove all child meshes and dispose their geometries and materials
            while(this.mesh.children.length > 0) {
                const child = this.mesh.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(material => material.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
                this.mesh.remove(child);
            }
            
            // Dispose the main mesh's geometry and material
            if (this.mesh.geometry) this.mesh.geometry.dispose();
            if (this.mesh.material) {
                if (Array.isArray(this.mesh.material)) {
                    this.mesh.material.forEach(material => material.dispose());
                } else {
                    this.mesh.material.dispose();
                }
            }
            
            // Remove from scene
            this.scene.remove(this.mesh);
            this.mesh = null;
        }
        this.isActive = false;
    }
    
    getPosition() {
        return this.mesh ? this.mesh.position : new THREE.Vector3();
    }
} 
```

```
// waitingRoom.js
// WaitingRoom.js
import * as THREE from 'three';
import { createStandardMaterial, createBoxGeometry } from './utils.js'; // Use your utils
import { Portal } from './portal.js'; // Need portal to get back

export function createWaitingRoomScene(mainSceneName, mainAreaSpawnPoint) {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xcccccc); // Bland office background color

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // --- Basic Office Geometry ---
    const floorSize = 20;
    const wallHeight = 5;

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
    const floorMaterial = createStandardMaterial(0x888888, 1.0); // Simple grey floor
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Walls (using simple boxes)
    const wallMaterial = createStandardMaterial(0xd1d1d1, 1.0); // Off-white walls
    const wallThickness = 0.2;

    // Back Wall
    const backWall = new THREE.Mesh(
        createBoxGeometry(floorSize, wallHeight, wallThickness),
        wallMaterial
    );
    backWall.position.set(0, wallHeight / 2, -floorSize / 2);
    scene.add(backWall);

    // Front Wall (with potential gap for entrance?) - let's make it solid for now
     const frontWall = new THREE.Mesh(
        createBoxGeometry(floorSize, wallHeight, wallThickness),
        wallMaterial
     );
     frontWall.position.set(0, wallHeight / 2, floorSize / 2);
     scene.add(frontWall);

    // Left Wall
    const leftWall = new THREE.Mesh(
        createBoxGeometry(wallThickness, wallHeight, floorSize),
        wallMaterial
    );
    leftWall.position.set(-floorSize / 2, wallHeight / 2, 0);
    scene.add(leftWall);

    // Right Wall
    const rightWall = new THREE.Mesh(
        createBoxGeometry(wallThickness, wallHeight, floorSize),
        wallMaterial
    );
    rightWall.position.set(floorSize / 2, wallHeight / 2, 0);
    scene.add(rightWall);

     // --- Furniture --- (Very basic examples)
     const chairMaterial = createStandardMaterial(0x593a2a, 1.0); // Brownish
     const chairSeatGeo = createBoxGeometry(0.8, 0.2, 0.8);
     const chairBackGeo = createBoxGeometry(0.8, 1.0, 0.1);
     const legGeo = createBoxGeometry(0.1, 0.5, 0.1);

     function createChair(x, z, rotationY = 0) {
         const chairGroup = new THREE.Group();
         const seat = new THREE.Mesh(chairSeatGeo, chairMaterial);
         seat.position.y = 0.5; // Seat height
         chairGroup.add(seat);

         const back = new THREE.Mesh(chairBackGeo, chairMaterial);
         back.position.set(0, 1.0, -0.4); // Behind seat
         chairGroup.add(back);

         // Add legs (simple example)
         const leg1 = new THREE.Mesh(legGeo, chairMaterial); leg1.position.set(0.35, 0.25, 0.35); chairGroup.add(leg1);
         const leg2 = new THREE.Mesh(legGeo, chairMaterial); leg2.position.set(-0.35, 0.25, 0.35); chairGroup.add(leg2);
         const leg3 = new THREE.Mesh(legGeo, chairMaterial); leg3.position.set(0.35, 0.25, -0.35); chairGroup.add(leg3);
         const leg4 = new THREE.Mesh(legGeo, chairMaterial); leg4.position.set(-0.35, 0.25, -0.35); chairGroup.add(leg4);

         chairGroup.position.set(x, 0, z);
         chairGroup.rotation.y = rotationY;
         scene.add(chairGroup);
         return chairGroup;
     }

     createChair(-floorSize/2 + 2, -floorSize/2 + 3, Math.PI / 4);
     createChair(-floorSize/2 + 4, -floorSize/2 + 3, Math.PI / 4);
     createChair(-floorSize/2 + 6, -floorSize/2 + 3, Math.PI / 4);


    // --- Return Portal ---
    const returnPortalPosition = new THREE.Vector3(5, 2.5, floorSize / 2 - 2); // Increased Y from 8.5 to 15.5
    const returnPortal = new Portal(
        scene,
        returnPortalPosition,
        1.5, // Increased size from 1.0 to 1.5
        mainSceneName, // Target scene name (passed in)
        mainAreaSpawnPoint // Target spawn point (passed in)
    );
    // Store portal reference in the scene for easy access during update
    scene.userData.portals = [returnPortal];
    scene.userData.spawnPoint = new THREE.Vector3(0, 2, 0); // Default spawn point inside the room

    return scene;
}
```

```
// fix-bars.js
// Script to fix the transparent bars by targeting chat-messages elements
document.addEventListener('DOMContentLoaded', function() {
    function fixChatMessages() {
        // First, find all chat-messages elements
        const chatMessagesElements = document.querySelectorAll('#chat-messages');
        
        // Save all welcome messages from any containers
        const welcomeMessages = [];
        chatMessagesElements.forEach(el => {
            Array.from(el.children).forEach(child => {
                // Specifically check for and save welcome messages
                if (child.textContent.includes("Welcome to the Cyberpunk Pier")) {
                    welcomeMessages.push({
                        className: child.className || 'message system-message',
                        text: child.textContent
                    });
                }
            });
        });
        
        if (chatMessagesElements.length > 1) {
            console.log('Found multiple chat-messages elements, keeping only the one at the bottom');
            
            // Save messages from all containers
            const allMessages = [];
            chatMessagesElements.forEach(el => {
                Array.from(el.children).forEach(child => {
                    allMessages.push({
                        className: child.className,
                        text: child.textContent
                    });
                });
            });
            
            // Keep only the one with bottom positioning
            let keepElement = null;
            
            chatMessagesElements.forEach(el => {
                const style = window.getComputedStyle(el);
                const rect = el.getBoundingClientRect();
                
                // Check if it's positioned at the top or doesn't have explicit bottom positioning
                if (style.top === '0px' || 
                    (!el.style.bottom && el.style.bottom !== '80px') || 
                    rect.top < 100) {
                    
                    console.log('Removing chat-messages element positioned at the top');
                    el.remove();
                } else {
                    // This is a properly positioned chat element at the bottom
                    keepElement = el;
                }
            });
            
            // If we have a properly positioned element, restore all messages to it
            if (keepElement) {
                // Clear existing messages first to avoid duplicates
                keepElement.innerHTML = '';
                
                // Add all messages to the container we're keeping
                allMessages.forEach(msg => {
                    const messageElement = document.createElement('div');
                    messageElement.className = msg.className;
                    messageElement.textContent = msg.text;
                    keepElement.appendChild(messageElement);
                });
            }
        }
        
        // Make sure the remaining chat-messages element is positioned correctly
        const remainingChatMessages = document.getElementById('chat-messages');
        if (remainingChatMessages) {
            // Save the existing messages
            const existingMessages = [];
            Array.from(remainingChatMessages.children).forEach(child => {
                existingMessages.push({
                    className: child.className,
                    text: child.textContent
                });
            });
            
            // Set correct styling
            remainingChatMessages.setAttribute('style', 
                'position: fixed !important; ' +
                'bottom: 80px !important; ' +
                'top: auto !important; ' +
                'left: 50% !important; ' +
                'transform: translateX(-50%) !important; ' +
                'width: 80% !important; ' +
                'max-width: 800px !important; ' +
                'max-height: 200px !important; ' +
                'z-index: 1000 !important; ' +
                'background-color: rgba(0, 0, 0, 0.7) !important; ' +
                'border: 1px solid #00ff9d !important; ' +
                'border-radius: 25px !important; ' +
                'padding: 10px !important; ' +
                'overflow-y: auto !important;'
            );
            
            // Restore messages that might have been cleared by setting the style attribute
            if (remainingChatMessages.children.length === 0) {
                existingMessages.forEach(msg => {
                    const messageElement = document.createElement('div');
                    messageElement.className = msg.className;
                    messageElement.textContent = msg.text;
                    remainingChatMessages.appendChild(messageElement);
                });
            }
            
            // Make sure we have at least one welcome message
            let hasWelcomeMessage = false;
            Array.from(remainingChatMessages.children).forEach(child => {
                if (child.textContent.includes("Welcome to the Cyberpunk Pier")) {
                    hasWelcomeMessage = true;
                }
            });
            
            // If no welcome message but we found one earlier, add it back
            if (!hasWelcomeMessage && welcomeMessages.length > 0) {
                console.log('Restoring welcome message from saved messages');
                const msg = welcomeMessages[0];
                const messageElement = document.createElement('div');
                messageElement.className = msg.className;
                messageElement.textContent = msg.text;
                remainingChatMessages.appendChild(messageElement);
            }
        }
    }
    
    // Run the fix immediately
    fixChatMessages();
    
    // And then every 500ms for the first few seconds to catch any that are created dynamically
    setTimeout(fixChatMessages, 500);
    setTimeout(fixChatMessages, 1000);
    setTimeout(fixChatMessages, 2000);
    
    // Create a direct welcome message function that can be called later
    window.addWelcomeMessage = function() {
        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) {
            // Check if we already have a welcome message
            let hasWelcomeMessage = false;
            Array.from(chatMessages.children).forEach(child => {
                if (child.textContent.includes("Welcome to the Cyberpunk Pier")) {
                    hasWelcomeMessage = true;
                }
            });
            
            // If no welcome message, add it
            if (!hasWelcomeMessage) {
                const messageElement = document.createElement('div');
                messageElement.className = 'message system-message';
                messageElement.textContent = "Welcome to the Cyberpunk Pier! Press E to throw vinyl discs.";
                chatMessages.appendChild(messageElement);
            }
        }
    };
    
    // Add welcome message after all other processes
    setTimeout(window.addWelcomeMessage, 3000);
    
    // Set up a MutationObserver to detect when new elements are added
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                // Run the fix when new elements are added
                fixChatMessages();
            }
        });
    });
    
    // Start observing the body for added/removed nodes
    observer.observe(document.body, { childList: true, subtree: true });
}); 
```

```
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emo World</title>
    <link rel="stylesheet" href="style.css">
    <style>
        #chat-container {
            display: none; /* Hide chat container by default */
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>

    <div id="chat-container">
        <ul id="chat-messages">
            <!-- Messages will be added here by JavaScript -->
        </ul>
        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="Type message...">
            <button id="chat-submit">Send</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three/addons/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
                "three/addons/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js",
                "three/addons/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
                "three/addons/postprocessing/RenderPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
                "three/addons/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js",
                "three/addons/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"
            }
        }
    </script>

    <script type="module">
        import { EBOYIsometricPierScene } from './js/main.js';

        // Initialize the application when the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const app = new EBOYIsometricPierScene();
        });
    </script>
</body>
</html>
```

```
// style.css
body {
    margin: 0;
    overflow: hidden; /* Prevent scrollbars */
    font-family: 'Courier New', Courier, monospace; /* Cyberpunk feel */
    background-color: #000; /* Black background */
    color: #00ff00; /* Green text */
}

#scene-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

#chat-container {
    position: fixed;
    bottom: 20px; /* Position above potential input */
    left: 20px;
    width: 500px; /* Increased width */
    max-height: 300px; /* Increased height */
    background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
    border: 1px solid #00ff00; /* Green border */
    border-radius: 5px;
    overflow: hidden; /* Hide outer scrollbar */
    display: flex; /* Use flexbox for layout */
    flex-direction: column; /* Stack elements vertically */
    opacity: 0.8; /* Slightly transparent */
    visibility: visible; /* Make sure it's visible */
    z-index: 10; /* Ensure it's above the canvas */
    padding: 5px;
}


#chat-messages {
    list-style: none;
    padding: 5px 10px;
    margin: 0;
    overflow-y: auto; /* Enable vertical scrolling */
    flex-grow: 1; /* Allow messages list to take available space */
    color: #00ff00; /* Default text color */
    font-size: 14px; /* Increased font size */
}

/* Style scrollbar for webkit browsers */
#chat-messages::-webkit-scrollbar {
    width: 8px;
}

#chat-messages::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.5);
    border-radius: 4px;
}

#chat-messages::-webkit-scrollbar-thumb {
    background-color: #00cc00;
    border-radius: 4px;
    border: 2px solid rgba(0, 0, 0, 0.5);
}


/* Individual message styling */
#chat-messages li {
    margin-bottom: 5px;
    word-wrap: break-word; /* Wrap long messages */
}

.message-system {
    color: #ffff00; /* Yellow for system messages */
    font-style: italic;
}

.message-player {
    color: #00ffff; /* Cyan for player messages */
}

.message-npc {
    color: #ff9900; /* Orange for NPC messages */
}

.sender-name {
    font-weight: bold;
} 
```